<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Diary</title>
      <link href="/Diary_1_17_2020.html"/>
      <url>/Diary_1_17_2020.html</url>
      
        <content type="html"><![CDATA[<h2 id="手账"><a class="markdownIt-Anchor" href="#手账"></a> 手账</h2><p>营业时间：5h</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>1h30min</td><td>雅思测试</td></tr><tr><td>3h</td><td>数据库week1 第二个ppt</td></tr><tr><td>30min</td><td>单词</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database Week 1</title>
      <link href="/Database_week1.html"/>
      <url>/Database_week1.html</url>
      
        <content type="html"><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><h3 id="三个数据库基本概念"><a class="markdownIt-Anchor" href="#三个数据库基本概念"></a> 三个数据库基本概念</h3><ul><li><p>Data: facts and statistics collected together for reference or analysis.<br />数据:收集在一起作为参考或分析的事实和统计数据。</p></li><li><p>[背]<strong>Database</strong>: a shared collection of logically related data, designed to meet the information needs of an organization.<br />数据库:为满足组织的信息需求而设计的逻辑相关数据的共享集合。</p></li><li><p>System catalogue provides description of data to enable program–data independence.<br />系统目录提供数据的描述，使程序数据独立。</p></li></ul><h3 id="数据的三个性质"><a class="markdownIt-Anchor" href="#数据的三个性质"></a> 数据的三个性质</h3><ul><li><p>[背]Logically related data comprises <strong>entities</strong>, <strong>attributes</strong>, and <strong>relationships</strong> of an organization’s information.<br />逻辑相关的数据包括实体、属性和组织信息的关系。</p></li><li><p>Entity: a distinct object in the organization that is to be represented in the database. E.g. person, place, thing, etc<br />实体:组织中要在数据库中表示的不同对象。 例如:人、地点、事物等</p></li><li><p>Attribute: a property that describes some aspect of the object that we wish to record.<br />属性:描述我们希望记录的对象的某个方面的属性。</p></li><li><p>Relationship: an association between entities.<br />关系:实体之间的关联</p></li></ul><h3 id="dbms相关的概念"><a class="markdownIt-Anchor" href="#dbms相关的概念"></a> DBMS相关的概念</h3><ul><li><p>DBMS: A <strong>software system</strong> that enables users to define, create, maintain, and control access to the database.<br />DBMS: 允许用户定义、创建、维护和控制对数据库的访问的软件系统。</p></li><li><p>application program: a computer program that interacts with database by issuing an appropriate request through SQL statement to the DBMS.<br />数据库应用程序:通过向DBMS发出适当的请求通过SQL语句来与数据库交互的计算机程序。</p></li></ul><h3 id="一些其他的重要概念"><a class="markdownIt-Anchor" href="#一些其他的重要概念"></a> 一些其他的重要概念</h3><ul><li><p>Data model：A model is a representation of ‘real world’ objects and events, and their associations.<br />数据模型:模型是“真实世界”对象和事件及其关联的表示。</p></li><li><p>Schema vs Data  模式 vs 数据</p></li></ul><table><thead><tr><th>Name</th><th>Explaination</th></tr></thead><tbody><tr><td>Schema</td><td>The <strong>description</strong> of the database</td></tr><tr><td>Data</td><td>Actual information stored in the database</td></tr></tbody></table><ul><li><p>Data definition language  [DDL]   数据定义语言</p></li><li><p>Data manipulation language  [DML]   数据操作语言</p></li></ul><h3 id="roles-in-the-database-environment重要"><a class="markdownIt-Anchor" href="#roles-in-the-database-environment重要"></a> Roles in the Database Environment[重要]</h3><ul><li>Data Administrator   DA   数据管理员</li><li>Database Administrator   DBA  数据库管理员</li><li>Database Designers 数据库设计员</li><li>Application Developers 应用程序开发人员</li><li>End Users 最终用户</li></ul><h3 id="the-three-level-ansi-sparc-architecture"><a class="markdownIt-Anchor" href="#the-three-level-ansi-sparc-architecture"></a> The three-level ANSI-SPARC architecture</h3><ul><li>External level</li><li>Conceptual level</li><li>Internal level</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F1.png" alt="three-level ANSI-SPARC architecture" /></p><hr /><h2 id="relational-model-关系模型"><a class="markdownIt-Anchor" href="#relational-model-关系模型"></a> Relational model 关系模型</h2><h3 id="terminology-术语"><a class="markdownIt-Anchor" href="#terminology-术语"></a> Terminology 术语</h3><ul><li><p>Relation model: all data is logically structured within relations.<br />关系模型:所有数据在关系中逻辑结构化。</p></li><li><p>Relation: A relation is a table with columns and rows.<br />关系:关系是一个包含列和行的表。</p></li><li><p>Attribute: An attribute is a named column of a relation.<br />属性:属性是关系的命名列。</p></li><li><p>Domain: the set of allowable values for one or more attributes.<br />域:一个或多个属性的允许值集。   (属性的取值范围)</p></li><li><p>Tuple: A tuple is row of a relation.<br />元组: 元组是关系的行。   (数据库的表中的某一行)</p></li><li><p>Degree: the number of attributes in a relation.<br />度:关系中属性的数量。   (数据库的表中有多少个属性列)</p></li><li><p>Cardinality: the number of tuples in a relation.<br />基数:关系中元组的数量。    (数据库的表共有多少行)</p></li><li><p>Relational database: A collection of normalized relations with distinct relation names.<br />关系数据库:一组具有不同关系名称的规范化关系。</p></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F2.png" alt="术语在数据库表中的对应" /></p><h3 id="creating-relations-tables-in-sql-创表sql语句"><a class="markdownIt-Anchor" href="#creating-relations-tables-in-sql-创表sql语句"></a> Creating relations [tables] in SQL [创表SQL语句]</h3><ul><li>Create Table <TableName>(&lt;attribute 1&gt; &lt;attribute_type 1&gt;, &lt;attribute 2&gt; &lt;attribute_type 2&gt;,…)</li><li>eg: Create Table Branch(branchNo integer, street string, city string, postcode char(6))</li></ul><h3 id="properties-of-relations-关系的属性-不重要"><a class="markdownIt-Anchor" href="#properties-of-relations-关系的属性-不重要"></a> Properties of relations 关系的属性 [不重要]</h3><ul><li><p>Relation name is distinct from all other relation names in relational schema.<br />关系名称与关系模式中的所有其他关系名称不同。</p></li><li><p>Each cell of relation contains exactly one single value. [First normal form]<br />每个关系单元只包含单个值。[第一范式]</p></li><li><p>Each attribute has a distinct name.<br />每个属性都有一个不同的名称。</p></li><li><p>Values of an attribute are all from the same domain.<br />一个属性的值都来自同一个域。</p></li><li><p>Each tuple is distinct; there are no duplicate tuples.<br />每个元组是不同的;没有重复的元组。</p></li><li><p>Order of attributes has no significance.<br />属性的顺序没有意义。</p></li><li><p>Order of tuples has no significance, theoretically.<br />从理论上讲，元组的顺序没有意义。</p></li></ul><h3 id="relational-keys-关系键重点"><a class="markdownIt-Anchor" href="#relational-keys-关系键重点"></a> Relational keys 关系键[重点]</h3><h5 id="candidate-key-候选键"><a class="markdownIt-Anchor" href="#candidate-key-候选键"></a> Candidate Key 候选键</h5><ul><li>Defination：A set of attributes that uniquely identifies a tuple within a relation.<br />定义: 在关系中唯一标识元组的一组属性。</li><li>Uniqueness: In each tuple, candidate key uniquely identify that tuple.<br />惟一性: 在每个元组中，候选键唯一地标识该元组。</li><li>Irreducibility: No proper subset of the candidate key has the uniqueness property.<br />不可约性: 候选键的任何固有子集都不具有唯一性。？？？？？？？？？？？？？</li><li>候选键的定义与主键和外键不并列。</li></ul><h5 id="primary-key-主键"><a class="markdownIt-Anchor" href="#primary-key-主键"></a> Primary Key 主键</h5><ul><li>Defination: Candidate key selected to identify tuples uniquely within relation.<br />定义:选择候选键来唯一地标识关系中的元组。</li></ul><h5 id="foreign-key-外键"><a class="markdownIt-Anchor" href="#foreign-key-外键"></a> Foreign Key 外键</h5><ul><li>Defination: Attribute, or set of attributes, within one relation that matches candidate key of some (possibly same) relation.<br />定义:在一个关系中匹配某个(可能相同的)关系的候选键的属性或属性集。</li></ul><h3 id="representing-relational-schema-关系模式的表示方法"><a class="markdownIt-Anchor" href="#representing-relational-schema-关系模式的表示方法"></a> Representing Relational Schema 关系模式的表示方法</h3><ul><li>Relation name [attribute 1, attribute 2, … attribute n]<br />eg: Branch [branchNo, street, city, postcode]<br />eg: Staff [staffNo, fName, lName, position, sex, DOB, salary, branchNo]</li></ul><h3 id="integrity-constraints-完整性约束"><a class="markdownIt-Anchor" href="#integrity-constraints-完整性约束"></a> Integrity Constraints 完整性约束</h3><h5 id="null"><a class="markdownIt-Anchor" href="#null"></a> Null</h5><ul><li><p>Represents value for an attribute that is currently unknown or not applicable for tuple.<br />表示当前未知或不适用于元组的属性的值。</p></li><li><p>Deals with incomplete or exceptional data.<br />处理不完整或异常的数据。</p></li><li><p>Represents the absence of a value [It is not the same as zero or spaces, which are values].<br />表示没有值[不代表0或空格的含义，它们是值]。</p></li></ul><h5 id="entity-integrity-实体完整性-必须有主键"><a class="markdownIt-Anchor" href="#entity-integrity-实体完整性-必须有主键"></a> Entity Integrity 实体完整性 [必须有主键]</h5><p>In a base relation, no attribute of a primary key can be null.<br />在基本关系中，主键的任何属性都不能为空。</p><h5 id="referential-integrity-参照完整性-外键如果存在就必须是候选键"><a class="markdownIt-Anchor" href="#referential-integrity-参照完整性-外键如果存在就必须是候选键"></a> Referential Integrity 参照完整性 [外键如果存在就必须是候选键]</h5><p>If foreign key exists in a relation, either foreign key value must match a candidate key value of some tuple in its home relation or foreign key value must be null.<br />如果一个关系中存在外键，那么要么外键值必须匹配其主关系中某个元组的候选键值，要么外键值必须为空。</p><h5 id="general-constraints"><a class="markdownIt-Anchor" href="#general-constraints"></a> General Constraints</h5><hr /><h2 id="relational-algebra-关系代数"><a class="markdownIt-Anchor" href="#relational-algebra-关系代数"></a> Relational Algebra 关系代数</h2><ul><li><p>Relational algebra is formal language associated with the relational model.<br />关系代数是与关系模型相关的正式语言。</p></li><li><p>Relational algebra operations work on one or more relations to define another relation without changing the original relations.<br />关系代数运算处理一个或多个关系，以定义另一个关系，而不改变原始关系。</p></li><li><p>Allows expressions to be nested, just as in arithmetic. This property is called <strong>closure</strong>.<br />允许表达式嵌套，就像在算术中一样。这个属性称为闭包。</p></li></ul><h3 id="operations"><a class="markdownIt-Anchor" href="#operations"></a> Operations</h3><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Selection</td><td>选择</td></tr><tr><td>Projection</td><td>映射</td></tr><tr><td>Cartesian product</td><td>笛卡尔积</td></tr><tr><td>Union</td><td>合集</td></tr><tr><td>Set difference</td><td>差集</td></tr><tr><td>Join</td><td>取并</td></tr><tr><td>Intersection</td><td>取交</td></tr><tr><td>Division</td><td>除？？不知如何翻译</td></tr></tbody></table><ul><li>Selection<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F7.png" alt="Selection" /></li></ul><p>处理单个关系R，并定义仅包含满足指定条件的R元组的关系。<br /><strong>通过筛选值取n整行</strong><br />eg: 列出所有年薪超过1万英镑的员工。<br />eg: 列出所有年薪超过1万英镑的女性员工<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F3.png" alt="Selection" /></p><ul><li><p>Projection<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F8.png" alt="Projection" /><br />处理单个关系R并定义包含R的垂直子集的关系，提取指定属性的值并消除重复。<br /><strong>通过筛选属性取n整列</strong><br />eg: 列出所有员工的薪资，只显示 <staffNo>, <fName>, <lName> and <salary details>.<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F4.png" alt="Projection" /></p></li><li><p>Cartesian product<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F10.png" alt="Cartesian product" /><br />定义一个关系，该关系是关系R的每个元组与关系S的每个元组的连接。<br /><strong>通过建立属性关系选取n列</strong><br />eg: 列出所有看过出租物业的客户的姓名及意见<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F5.png" alt="Cartesian product" /></p></li><li><p>Join:<br />Derivative of Cartesian product, equivalent to performing a Selection operation, using the join condition as the selection formula, over the Cartesian product of the two operand relations.<br />连接:笛卡尔积的导数，相当于执行一个选择操作，使用连接条件作为选择公式，除以两个操作数关系的笛卡尔积。？？？？</p><ul><li>Natural Join: 合并所有相同属性的相同值所在的行<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F12.png" alt="Natural Join" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F6.png" alt="Natural Join" /></li><li>Theta Join: 定义一个关系，该关系包含满足条件F的元组，这些条件来自于R和S的笛卡尔积。<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F14.png" alt="Theta Join" /></li></ul></li><li><p>Union<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F15.png" alt="Union" /><br />在关系R或关系S中的元组的整体组成的关系。</p></li><li><p>Set difference<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F16.png" alt="Set difference" /><br />在关系R中但不在关系S中的元组组成的关系。<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F17.png" alt="Set difference" /></p></li><li><p>Intersection<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F18.png" alt="Intersection" /><br />在关系R中且在关系S中的元组组成的关系。<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F19.png" alt="Intersection" /></p></li><li><p>Division 难点<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F20.png" alt="Division" /></p></li></ul><p>S在属性C上定义一个关系，该关系由来自R的一组元组组成，这些元组匹配S中<strong>每个</strong>元组的组合。</p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F21.png" alt="Division" /></p><h3 id="练习题"><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F9.png" alt="Practice 1" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F11.png" alt="Practice 2" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F13.png" alt="Practice 3" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F22.png" alt="Practice 4" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F23.png" alt="Practice 5" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F24.png" alt="Practice 6" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F25.png" alt="Practice 7" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts%2FDatabase%2FDatabase_week1%2F26.png" alt="Practice 8" /></p><h2 id="entity-relationshiper-modelling"><a class="markdownIt-Anchor" href="#entity-relationshiper-modelling"></a> Entity-relationship(ER) modelling</h2>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diary</title>
      <link href="/Diary_1_16_2020.html"/>
      <url>/Diary_1_16_2020.html</url>
      
        <content type="html"><![CDATA[<h2 id="日记"><a class="markdownIt-Anchor" href="#日记"></a> 日记</h2><ul><li><p>长春莲花山滑雪场一日游~ [此处能来个定位插件就完美了…]<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_16_2020%2F1.jpg" alt="dlt &amp; me" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_16_2020%2F2.jpg" alt="高中同学们" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_16_2020%2F3.jpg" alt="索道上的我俩" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_16_2020%2F4.jpg" alt="霸气的索道入口" /></p></li><li><p>第一次滑雪！解锁了莲花山的所有雪道<sub>看起来有一点天赋的样子</sub>滑雪真的巨累！晚上七点到家沾床睡到十点…</p></li><li><p>遇到了很热心的司机，这年头谁都不容易，掩饰住为生计奔走的辛苦的同时还能热心帮助身边的人真的是不容易~</p></li><li><p>在莲花山食堂发现，下次吃饺子可以多放点蒜汁少放醋，这样味道似乎更好233</p></li></ul><h2 id="手账"><a class="markdownIt-Anchor" href="#手账"></a> 手账</h2><p>营业时间：2h30min</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>30min</td><td>两节概率论网课 1-3,1-4</td></tr><tr><td>30min</td><td>毛概第一章看了一遍，需要巩固</td></tr><tr><td>30min</td><td>单词打卡</td></tr><tr><td>1h</td><td>数据库week1 第一个ppt</td></tr></tbody></table><h2 id="todolist"><a class="markdownIt-Anchor" href="#todolist"></a> TodoList</h2><ul><li>单词坚持打卡！</li><li>明天把毛概第一章背一遍，大概2h</li><li>明天去环球雅思雅思测试</li><li>数据库week 1 搞完</li><li>背完单词没事干了用手机看概率论</li></ul>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Diary</title>
      <link href="/Diary_1_15_2020.html"/>
      <url>/Diary_1_15_2020.html</url>
      
        <content type="html"><![CDATA[<h2 id="现实世界给不了你的你的心可以给你"><a class="markdownIt-Anchor" href="#现实世界给不了你的你的心可以给你"></a> 现实世界给不了你的，你的心可以给你。</h2><ul><li>日记的具体的作用有：</li></ul><table><thead><tr><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>日记</td><td>描述当日发生的值得记录的事情</td></tr><tr><td>手账</td><td>当天做了哪些有意义的事情</td></tr><tr><td>Todolist</td><td>第二天计划要做什么</td></tr></tbody></table><h2 id="日记"><a class="markdownIt-Anchor" href="#日记"></a> 日记</h2><ul><li>再次经历了一次一整晚和爸妈交流的激烈表述，我们终于制定了我研究生去向相关的提前安排：出国考研两手准备为保研提供后路，如果大二下学期成绩没能进入专业前55名，保研就算失败，大三开始准备留学英国的雅思语言考试，同时开始为考研做准备。如果有幸在大二下学期的考试中从现在的74名冲到55名以里，再在大三期间全力做保研的努力。</li><li>本科学习路线flag已立，希望这次能坚持住不动摇！</li><li>和仙女重温了新生活的南洋小馆，点了熟悉的炆颈肉和小米煨豆腐~</li><li>和仙女一起喝了招牌的牛魔王味道的奶茶，和黑糖的味道很像。</li><li>和仙女一起坐了半个小时的按摩椅，她竟然没反感按摩椅不舒服哈哈哈。一起足疗有望！上次一起在按摩椅上睡着还是去年跨年。真快<br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_15_2020%2F1.jpg" alt="美美的我们2333" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_15_2020%2F2.jpg" alt="帅气的我~" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts%2FDiary%2FDiary_1_15_2020%2F3.jpg" alt="美美的我们~" /></li><li>还买了仙女的卷发棒和我的刮胡刀，这是她给我买的第三个刮胡刀了…之前的丢了一个，一个在学校。</li><li>一起玩了那个转动插空隙赢口红的机器，哈哈哈凭实力用试玩玩到第二关推理出第三关是不可能难度，省去浪费的十块钱哈哈哈~</li><li>仙女22号要和高中同学出去玩。。。是不是这个日子，我这记性</li><li>仙女似乎突然不喜欢吃菜花了。。。吃多了？</li><li>爱情公寓5我看到了11集~仙女才看到第9集，记下来，这个要考。。。</li><li>她特别激动地给我复述她实习过程中打电话的桥段的时候真的超可爱！！她都这么努力，我是不是应该更努力些~</li><li>假期决定开始雅思学习！不能浪费钱，好好学。</li><li>明天去莲花山和高中同学滑雪<sub>早点睡</sub>可是现在已经两点半了。。。</li></ul><h2 id="手账"><a class="markdownIt-Anchor" href="#手账"></a> 手账</h2><p>营业时间：30min</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>30min</td><td>晚上陪仙女吃饭前看了两节概率论</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Supporting Technologies of IoT</title>
      <link href="/Supporting%20Technologies%20of%20IoT.html"/>
      <url>/Supporting%20Technologies%20of%20IoT.html</url>
      
        <content type="html"><![CDATA[<h2 id="61-cloud-computing"><a class="markdownIt-Anchor" href="#61-cloud-computing"></a> 6.1 Cloud Computing</h2><ul><li>网络计算方式的进化</li></ul><table><thead><tr><th>Name</th><th>名字</th></tr></thead><tbody><tr><td>Network Computing</td><td>网络计算</td></tr><tr><td>Cluster Computing</td><td>集群计算</td></tr><tr><td>Grid Computing</td><td>格网计算</td></tr><tr><td>Utility Computing</td><td>效用计算</td></tr><tr><td>Cloud Computing</td><td>云计算</td></tr></tbody></table><ul><li>云计算要点</li></ul><table><thead><tr><th>Name</th><th>名字</th></tr></thead><tbody><tr><td>Shared pool of configurable computing resources</td><td>可配置计算资源的共享池</td></tr><tr><td>On-demand network access</td><td>按需网络访问</td></tr><tr><td>Provisioned by the Service Provider</td><td>由服务提供者提供</td></tr><tr><td>hide the complexity</td><td>隐藏底层的复杂性</td></tr><tr><td>anywhere, anytime and any place</td><td></td></tr><tr><td>Pay for use</td><td>按需支付</td></tr><tr><td>hardware and software service</td><td></td></tr></tbody></table><ul><li>pros and cons of Cloud Computer</li></ul><table><thead><tr><th>pros</th><th>中文翻译</th></tr></thead><tbody><tr><td>Easy to conceptualize</td><td>容易概念化</td></tr><tr><td>Easy to deploy</td><td>容易部署（服务器）</td></tr><tr><td>Easy to backup</td><td>容易备份</td></tr><tr><td>any application/service can be run from this type of setup</td><td>兼容性强</td></tr></tbody></table><table><thead><tr><th>cons</th><th>中文翻译</th></tr></thead><tbody><tr><td>Expensive to acquire and maintain hardware</td><td>获取和维护硬件费用高</td></tr><tr><td>Not very scalable</td><td>不是很可伸缩</td></tr><tr><td>Difficult to replicate</td><td>难以复制</td></tr><tr><td>Vulnerable to hardware outages</td><td>容易出现硬件中断</td></tr></tbody></table><h3 id="virtual-server"><a class="markdownIt-Anchor" href="#virtual-server"></a> Virtual Server</h3><ul><li>Concepts<br />① Virtual servers seek to encapsulate the server software away from the hardware.<br />虚拟服务器试图将服务器软件封装在硬件之外.<br />② A virtual server can be serviced by one or more hosts, and one host may house more than one virtual server.<br />一个虚拟服务器可以由一个或多个主机提供服务，一个主机可以容纳多个虚拟服务器。<br />③ If the environment built correctly, virtual servers will not be affected by the loss of a host.<br />如果环境构建正确，虚拟服务器不会受到主机丢失的影响。<br />④ Can be scaled out easily.<br />可以很容易地扩展。</li><li>Advantages<br />① Run operating systems where the physical hardware is unavailable.<br />运行物理硬件不可用的操作系统<br />② Easier to create new machines, backup machines, etc.,<br />更容易创建新机器，备份机器等，<br />③ Software testing using “clean” installs of operating systems and software,<br />使用“干净”安装的操作系统和软件进行软件测试<br />④ Emulate more machines than are physically available<br />仿真比实际可用的更多的机器<br />⑤ Timeshare lightly loaded systems on one host<br />一个主机上的分时系统负载很轻<br />⑥ Debug problems (suspend and resume the problem machine)<br />调试问题(挂起并恢复问题机器)，<br />⑦ Easy migration of virtual machines<br />轻松迁移虚拟机<br />⑧ Run legacy systems!<br />遗留系统运行!</li><li>Pros and cons of virtualization</li></ul><table><thead><tr><th>pros</th><th>中文翻译</th></tr></thead><tbody><tr><td>Resource pooling</td><td>资源池</td></tr><tr><td>Highly redundant</td><td>高度冗余</td></tr><tr><td>Highly available</td><td>高可用性</td></tr><tr><td>Rapidly deploy new servers</td><td>快速部署新服务器</td></tr><tr><td>Easy to deploy</td><td>易于部署</td></tr><tr><td>Reconfigurable while services are running</td><td>服务运行时可重新配置</td></tr><tr><td>Optimizes physical resources by doing more with less</td><td>通过用更少的资源做更多的事情来优化物理资源</td></tr></tbody></table><table><thead><tr><th>cons</th><th>中文翻译</th></tr></thead><tbody><tr><td>harder to conceptualize</td><td>难以概念化</td></tr><tr><td>more costly</td><td>贵</td></tr></tbody></table><h3 id="layers-of-cloud-service-云计算层结构"><a class="markdownIt-Anchor" href="#layers-of-cloud-service-云计算层结构"></a> Layers of Cloud Service 云计算层结构</h3><table><thead><tr><th>layer</th><th>service</th><th>功能</th></tr></thead><tbody><tr><td>Client</td><td></td><td></td></tr><tr><td>Application</td><td>SaaS</td><td>为客户制作并维护应用程序</td></tr><tr><td>Platform</td><td>PaaS</td><td>为客户提供平台，API</td></tr><tr><td>Infrastructure</td><td>IaaS</td><td>为客户提供硬件资源</td></tr><tr><td>Server</td><td></td><td></td></tr></tbody></table><ul><li><p>SaaS<br />use provider’s applications running on provider’s cloud infrastructure.<br />使用运行在提供商云基础设施上的提供商应用程序。</p></li><li><p>PaaS<br />can create custom applications using programming tools supported by the provider and deploy them onto the provider’s cloud infrastructure.<br />可以使用提供商支持的编程工具创建自定义应用程序，并将它们部署到提供商的云基础设施上。</p></li><li><p>IaaS<br />provisions computing resources within provider’s infrastructure upon which they can deploy and run arbitrary software, including OS and applications.<br />在提供商的基础设施中提供计算资源，他们可以在这些资源上部署和运行任意软件，包括操作系统和应用程序。</p></li><li><p>知名云服务商<br />① Google Cloud<br />② VMware Cloud<br />③ IBM-Google Cloud<br />④ Salesforce Cloud</p></li><li><p>注重例子（看PPT）</p></li></ul><h3 id="hadoop"><a class="markdownIt-Anchor" href="#hadoop"></a> Hadoop</h3><p>用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。</p><table><thead><tr><th>framework</th><th>功能</th></tr></thead><tbody><tr><td>Hadoop Distributed File System (HDFS)</td><td>provide storage</td></tr><tr><td>MapReduce</td><td>provide processing</td></tr></tbody></table><h2 id="62-security-issue"><a class="markdownIt-Anchor" href="#62-security-issue"></a> 6.2 Security Issue</h2><h3 id="computer-security"><a class="markdownIt-Anchor" href="#computer-security"></a> Computer Security</h3><p>integrity（完整性）, availability（可用性） and confidentiality（保密性） of information system resources<br />保护信息系统资源的完整性、可用性和保密性<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Supporting_Technologies_of_IoT/1.png" alt="CIA Traid" /></p><p>Authenticity and Accountability 真实性和问责制</p><table><thead><tr><th>Key Objectives</th><th>具体体现</th><th>翻译</th></tr></thead><tbody><tr><td>Confidentiality</td><td>Concealment of information or resources</td><td>信息或资源的隐瞒</td></tr><tr><td></td><td>Data Confidentiality</td><td>数据保密性</td></tr><tr><td></td><td>Privacy</td><td>隐私</td></tr><tr><td>Integrity</td><td>Trustworthiness of data or resources</td><td>数据或资源的可靠性</td></tr><tr><td></td><td>Data Integrity</td><td>数据完整性</td></tr><tr><td></td><td>System Integrity</td><td>系统的完整性</td></tr><tr><td>Availability</td><td>Service not denied to authorized users</td><td>未拒绝授权用户的服务</td></tr><tr><td></td><td>Ability to use information or resources</td><td>能够使用信息或资源</td></tr><tr><td>Authenticity</td><td>being genuine, verified or trust</td><td>真实的，能够被核实或信任的</td></tr><tr><td></td><td>verifying the users</td><td>验证用户</td></tr><tr><td>Accountability</td><td>can be traced uniquely to that entity</td><td>唯一地追溯到该实体</td></tr></tbody></table><h4 id="computer-security-challenges"><a class="markdownIt-Anchor" href="#computer-security-challenges"></a> Computer Security Challenges</h4><ol><li>not simple</li><li>must consider potential attacks<br />必须考虑潜在的攻击</li><li>procedures used counter-intuitive<br />程序使用反直觉的</li><li>involve algorithms and secret info<br />涉及算法和秘密信息</li><li>must decide where to deploy mechanisms<br />必须决定在何处部署机制</li><li>battle of wits between attacker/administrator<br />攻击者/管理员之间的斗智斗勇</li><li>not perceived to be a benefit until fails<br />直到失败才被认为是有益的</li><li>requires regular monitoring<br />需要定期监测</li><li>too regarded as impediment to efficient and user friendly use of system<br />也被认为是高效和用户友好使用系统的障碍</li><li>often an after-thought<br />往往恍然大悟</li></ol><h4 id="osi-security-architecture-osi安全体系结构"><a class="markdownIt-Anchor" href="#osi-security-architecture-osi安全体系结构"></a> OSI Security Architecture OSI安全体系结构</h4><p>The OSI security architecture focuses on security <strong>attacks</strong>, <strong>mechanisms</strong> and <strong>services</strong>.<br />OSI的安全架构关注于安全攻击、机制和服务。</p><ul><li>Cryptography 密码学</li></ul><table><thead><tr><th>Cryptography Goals</th><th>翻译</th></tr></thead><tbody><tr><td>confidentiality</td><td>保密</td></tr><tr><td>data integrity</td><td>数据完整性</td></tr><tr><td>entity authentication</td><td>身份验证</td></tr><tr><td>Non-repudiation</td><td>不可抵赖性</td></tr></tbody></table><h5 id="要背的概念"><a class="markdownIt-Anchor" href="#要背的概念"></a> 要背的概念</h5><ul><li>Security Attack: Any action (active or passive) that compromises the security of information<br />安全攻击:危害信息安全的任何行为(主动或被动)</li><li>Security Mechanism: A mechanism that is designed to detect, prevent, or recover from a security attack.<br />安全机制:用于检测、防止或从安全攻击中恢复的机制。</li><li>Security Service: A service that enhances the security of data processing systems and information transfers. A security service makes use of one or more security mechanisms.<br />安全服务:提高数据处理系统和信息传输安全性的服务。安全服务使用一个或多个安全机制。</li><li>Threat: a potential for violation of security or a possible danger that might exploit a vulnerability<br />威胁: 潜在的安全威胁或可能利用漏洞的危险.</li><li>Attack: an intelligent act that is a deliberate attempt to evade security services and violate the security policy of a system.<br />攻击: 一种故意逃避安全服务和违反系统安全策略的智能行为。</li><li>填空<br />A <strong>Safeguard</strong> is a countermeasure to protect against a threat.<br />防护措施是防范威胁的对策。<br />A weakness in a safeguard is called a <strong>vulnerability</strong>.<br />安全防护中的弱点称为“漏洞”。<br />Damage to any IT-based system or activity can result in <strong>severe disruption of services and losses</strong>.<br />任何基于it的系统或活动的损坏都可能导致服务的严重中断和损失。</li></ul><h6 id="security-attacks"><a class="markdownIt-Anchor" href="#security-attacks"></a> Security Attacks</h6><ul><li>Interruption: This is an attack on availability<br />中断:这是对可用性的攻击</li><li>Interception: This is an attack on confidentiality<br />拦截:这是对保密性的攻击</li><li>Modification: This is an attack on integrity<br />修改:这是对完整性的攻击</li><li>Fabrication: This is an attack on authenticity<br />捏造:这是对真实性的攻击</li></ul><h6 id="security-threats"><a class="markdownIt-Anchor" href="#security-threats"></a> Security Threats</h6><ul><li>Disclosure: unauthorized access to information<br />披露-未经授权的信息访问</li><li>Deception: acceptance of false data<br />欺骗-接受虚假资料</li><li>Disruption: interruption or prevention of correct operation<br />中断-正确操作的中断或预防</li><li>Usurpation: unauthorized control of some part of a system<br />篡夺-对系统某些部分的未经授权的控制</li></ul><h6 id="passive-and-active-attacks-被动攻击和主动攻击"><a class="markdownIt-Anchor" href="#passive-and-active-attacks-被动攻击和主动攻击"></a> Passive and Active Attacks  被动攻击和主动攻击</h6><ul><li>Passive: attempts to learn or make use of information from the system, but does not affect system resources.<br />被动:尝试从系统中学习或利用信息，但不影响系统资源。</li><li>Active: attempts to alter system resources or affect their operation.<br />主动:试图改变系统资源或影响它们的操作。</li></ul><h4 id="security-services"><a class="markdownIt-Anchor" href="#security-services"></a> Security Services</h4><ul><li>enhance security of data processing systems and information transfers of an organization<br />提高数据处理系统和组织信息传输的安全性</li><li>intended to counter security attacks<br />为了对抗安全攻击</li><li>use one or more security mechanisms<br />使用一个或多个安全机制</li><li>often replicate functions normally associated with physical documents<br />经常复制通常与物理文档相关的功能</li><li>have signatures, dates; need protection from disclosure, tampering, or destruction; are notarized or witnessed;<br />有签名，日期;需要保护以免泄露、篡改或销毁;</li></ul><h5 id="security-services-examples"><a class="markdownIt-Anchor" href="#security-services-examples"></a> Security Services Examples</h5><table><thead><tr><th>Examples</th><th>解释</th><th>翻译</th></tr></thead><tbody><tr><td>uthentication</td><td>(who created or sent the data)</td><td>身份验证 (谁创建或发送数据)</td></tr><tr><td>Access control</td><td>(prevent misuse of resources)</td><td>访问控制 (防止资源滥用)</td></tr><tr><td>Confidentiality</td><td>(privacy)</td><td>机密性 (隐私)</td></tr><tr><td>Integrity</td><td>(has not been altered)</td><td>完整性 (未更改)</td></tr><tr><td>Non-repudiation</td><td>(the order is final)</td><td>不可抵赖性 (订单为最终)</td></tr><tr><td>Availability</td><td>(permanence, non-erasure)</td><td>可用性 (永久性、非擦除)</td></tr></tbody></table><h4 id="security-machanism"><a class="markdownIt-Anchor" href="#security-machanism"></a> Security Machanism</h4><ul><li>feature designed to detect, prevent, or recover from a security attack<br />用于检测、防止或从安全攻击中恢复的特性</li><li>no single mechanism that will support all services required<br />没有一种机制可以支持所有需要的服务</li><li>however one particular element underlies many of the security mechanisms in use: cryptographic techniques<br />然而，在使用的许多安全机制的基础上有一个特殊的元素:密码技术</li></ul><h5 id="security-machanism-examples"><a class="markdownIt-Anchor" href="#security-machanism-examples"></a> Security Machanism Examples</h5><ul><li>Specific mechanisms existing to provide certain security services<br />提供某些保安服务的特定机制</li></ul><table><thead><tr><th>Examples</th><th>翻译</th></tr></thead><tbody><tr><td>encryption used for authentication</td><td>用于身份验证的加密</td></tr><tr><td>digital signatures</td><td>数字签名</td></tr><tr><td>access controls</td><td>访问控制</td></tr><tr><td>data integrity</td><td>数据完整性</td></tr><tr><td>authentication exchange</td><td>身份验证交换</td></tr><tr><td>traffic padding</td><td>流量填充</td></tr><tr><td>routing control</td><td>路由控制</td></tr><tr><td>notarization</td><td>公证</td></tr></tbody></table><ul><li>Pervasive mechanisms which are general mechanisms incorporated into the system and not specific to a service<br />无处不在的机制，是纳入系统的一般机制，而不是特定于服务</li></ul><table><thead><tr><th>Examples</th><th>翻译</th></tr></thead><tbody><tr><td>security audit trail</td><td>安全审计跟踪</td></tr><tr><td>trusted functionality</td><td>信任的功能??</td></tr><tr><td>security labels</td><td>安全标签</td></tr><tr><td>event detection</td><td>事件检测</td></tr><tr><td>security recovery</td><td>安全恢复</td></tr></tbody></table><h3 id="two-types-of-program-threats"><a class="markdownIt-Anchor" href="#two-types-of-program-threats"></a> Two Types of Program Threats</h3><ul><li>Information access threats:<br />信息访问的威胁<br />Intercept or modify data on behalf of users who should not have access to that data.<br />代表不应该访问该数据的用户拦截或修改数据。<br />E.g. corruption of data by injecting malicious code<br />例如，注入恶意程式码破坏资料</li><li>Service threats:<br />服务的威胁<br />Exploit service flaws in computers to inhibit use by legitimate uses.<br />利用电脑上的服务漏洞，禁止合法使用。<br />Viruses and worms are examples of software attacks<br />病毒和蠕虫是软件攻击的例子</li></ul><h4 id="public-key-cryptosystems-公钥密码体制"><a class="markdownIt-Anchor" href="#public-key-cryptosystems-公钥密码体制"></a> Public-Key Cryptosystems 公钥密码体制</h4><table><thead><tr><th>categories</th><th>翻译</th></tr></thead><tbody><tr><td>Encryption/decryption</td><td>加密/解密</td></tr><tr><td>Digital signature</td><td>数字签名</td></tr><tr><td>Key exchange</td><td>密钥交换</td></tr></tbody></table><h4 id="advantage-of-symmetric-key-对称密钥的优点"><a class="markdownIt-Anchor" href="#advantage-of-symmetric-key-对称密钥的优点"></a> Advantage of Symmetric key  对称密钥的优点</h4><ul><li>It can be designed for high rates of data throughput, may be using hardware implementations<br />-它可以设计为高数据吞吐率，可以使用硬件实现</li><li>Key lengths are relatively short<br />-密钥长度相对较短</li><li>Can be used to produce stronger ciphers<br />-可用于产生更强的密码</li></ul><h4 id="disadvantage-of-symmetric-key-对称密钥的缺点"><a class="markdownIt-Anchor" href="#disadvantage-of-symmetric-key-对称密钥的缺点"></a> Disadvantage of Symmetric key  对称密钥的缺点</h4><ul><li>Key must remain secret at both ends<br />钥匙两端必须保密</li><li>In a large network, there are many key pairs to be managed. Effective key management requires use of an unconditionally trusted third party.<br />在大型网络中，有许多密钥对需要管理。有效的密钥管理需要使用一个无条件信任的第三方。</li><li>Digital signature schemes using private key cryptography requires large key.<br />使用私钥加密的数字签名方案需要大密钥。</li></ul><h4 id="advantage-of-public-key-cryptography-公钥密码学的优点"><a class="markdownIt-Anchor" href="#advantage-of-public-key-cryptography-公钥密码学的优点"></a> Advantage of Public key cryptography 公钥密码学的优点</h4><ul><li>Only the private key to be kept secret<br />只有私钥要保密</li><li>The administration of key requires only a functionally trusted TTP.<br />密钥的管理只需要一个功能可靠的TTP。</li><li>A private/public key pair may remain unchanged for a long time.<br />私钥/公钥对可能长时间保持不变。</li><li>Gives relatively efficient digital signature schemes<br />提供相对有效的数字签名方案</li></ul><h4 id="disadvantages-of-public-key-cryptography-公钥密码学的缺点"><a class="markdownIt-Anchor" href="#disadvantages-of-public-key-cryptography-公钥密码学的缺点"></a> Disadvantages of public key cryptography 公钥密码学的缺点</h4><ul><li>Several orders of magnitudes slower<br />慢了几个数量级</li><li>Key sizes are larger.<br />钥匙尺寸更大。</li><li>No public-key cryptosystem is proven to<br />secure.<br />没有公钥密码系统被证明是安全的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Information Processing for IoT</title>
      <link href="/Information%20Processing%20for%20IoT.html"/>
      <url>/Information%20Processing%20for%20IoT.html</url>
      
        <content type="html"><![CDATA[<h2 id="53-data-quality-数据质量"><a class="markdownIt-Anchor" href="#53-data-quality-数据质量"></a> 5.3 Data quality 数据质量</h2><h3 id="uncertain-data-不确定数据"><a class="markdownIt-Anchor" href="#uncertain-data-不确定数据"></a> Uncertain Data 不确定数据</h3><ul><li>Data uncertainty occur during:</li></ul><table><thead><tr><th>Name</th><th>名字</th></tr></thead><tbody><tr><td>Data collection</td><td>数据收集</td></tr><tr><td>Data transmission</td><td>数据传输</td></tr><tr><td>Data processing</td><td>数据处理</td></tr></tbody></table><h4 id="causes-of-data-uncertainty"><a class="markdownIt-Anchor" href="#causes-of-data-uncertainty"></a> Causes of Data Uncertainty</h4><table><thead><tr><th>Name</th><th>名字</th></tr></thead><tbody><tr><td>Environmental factors</td><td>环境因素</td></tr><tr><td>Low battery power</td><td>电池电量低</td></tr><tr><td>Packet losses</td><td>丢包</td></tr></tbody></table><h4 id="classification-of-data-uncertainty"><a class="markdownIt-Anchor" href="#classification-of-data-uncertainty"></a> Classification of Data Uncertainty</h4><ul><li>Source Classification 根据不确定数据的来源分类 （重点）</li></ul><table><thead><tr><th>Name</th><th>实例</th><th>翻译</th></tr></thead><tbody><tr><td>Undesirable uncertainty</td><td>Noisy sensor data</td><td></td></tr><tr><td></td><td>Imprecise GPS Data</td><td></td></tr><tr><td></td><td>Unreliable extracted/integrated data</td><td>不可靠的提取/集成数据</td></tr><tr><td>Desirable uncertainty</td><td>Medical data with generalized attributes</td><td>具有通用属性的医疗数据</td></tr><tr><td></td><td>Cloaked trajectory data</td><td>隐藏的轨迹数据</td></tr></tbody></table><ul><li>Granularity Classification 根据粒度分类</li></ul><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Tuple Uncertainty</td><td>元组的不确定性</td></tr><tr><td>Attribute Uncertainty</td><td>属性不确定性</td></tr></tbody></table><ul><li>Correlations Classification 根据相互关系分类</li></ul><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Independent Uncertainty</td><td>独立的不确定性</td></tr><tr><td>Correlated Uncertainty</td><td>相关的不确定性</td></tr><tr><td>Uncertainty with Local Correlations</td><td>局部相关不确定性</td></tr></tbody></table><h4 id="meaning-of-data-quality-数据质量的意义重点"><a class="markdownIt-Anchor" href="#meaning-of-data-quality-数据质量的意义重点"></a> Meaning of Data Quality 数据质量的意义（重点）</h4><ul><li>Generally, you have a problem if the data doesn’t mean what you think it does, or should.<br />通常情况下，如果数据的含义与您认为的不同，或者不应该相同，那么就会出现问题</li><li>Data quality problems are expensive and pervasive.<br />数据质量问题昂贵且普遍存在</li></ul><h4 id="conventional-definition-of-data-quality-数据质量的常规标准定义"><a class="markdownIt-Anchor" href="#conventional-definition-of-data-quality-数据质量的常规标准定义"></a> Conventional Definition of Data Quality 数据质量的常规标准（定义</h4><table><thead><tr><th>Name</th><th>翻译</th><th>解释</th></tr></thead><tbody><tr><td>Accuarcy</td><td>精度</td><td>recorded correctly</td></tr><tr><td>Completeness</td><td>完整</td><td>All data was recorded</td></tr><tr><td>Uniqueness</td><td>独一</td><td>recorded once</td></tr><tr><td>Timeliness</td><td>及时</td><td>The data is kept up to date</td></tr><tr><td>Consistency</td><td>一致</td><td>The data agrees with itself</td></tr></tbody></table><h2 id="54-data-cleaning-数据清理"><a class="markdownIt-Anchor" href="#54-data-cleaning-数据清理"></a> 5.4 Data Cleaning 数据清理</h2><p>the process of detecting and correcting (or removing) errors and inconsistencies from data in order to improve the quality of data.<br />To identifying incomplete, incorrect, inaccurate, irrelevant, etc.<br />从数据中检测和纠正(或消除)错误和不一致以提高数据质量的过程。<br />该技术目的在于识别不完整、不正确、不准确、不相关等。</p><h3 id="data-cleaning-tasks-数据清洗的任务-重点"><a class="markdownIt-Anchor" href="#data-cleaning-tasks-数据清洗的任务-重点"></a> Data cleaning tasks 数据清洗的任务 （重点）</h3><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Fill in missing values</td><td>填充缺失的值</td></tr><tr><td>Identify outliers and smooth out noisy data</td><td>识别异常值并平滑噪声数据</td></tr><tr><td>Correct inconsistent data</td><td>纠正不一致的数据</td></tr><tr><td>Resolve redundancy caused by data integration</td><td>解决数据集成造成的冗余</td></tr></tbody></table><h3 id="methods-to-handle-noisy-data"><a class="markdownIt-Anchor" href="#methods-to-handle-noisy-data"></a> Methods to Handle Noisy Data</h3><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td>Binning</td><td>装箱法，把数据按箱处理Smooth掉边缘数据</td></tr><tr><td>Regression</td><td>回归函数拟合</td></tr><tr><td>Clustering</td><td>聚类，检测到不属于大类的元素，删掉</td></tr><tr><td>Combined inspection</td><td>计算机和人工检查相结合</td></tr></tbody></table><h3 id="sensor-cleaning-pipeline"><a class="markdownIt-Anchor" href="#sensor-cleaning-pipeline"></a> Sensor Cleaning Pipeline</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/1.png" alt="Sensor Cleaning Pipeline" /></p><p>Uses temporal and spatial characteristics of sensor data<br />利用传感器数据的时空特性</p><h5 id="step-1-point"><a class="markdownIt-Anchor" href="#step-1-point"></a> Step 1: Point</h5><ul><li>Operates: Single value of sensor stream.<br />操作:单值传感器流。</li><li>Purpose: Filter individual values<br />目的:过滤单独的值<br />① Errant (dirty / faulty) RFID tags<br />错误的RFID标签<br />② Obvious outliers<br />明显的异常值<br />③ Conversion of raw data into tuples<br />将原始数据转换为元组<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/2.png" alt="Step 1: Point" /></li></ul><h5 id="step-2-smoothing"><a class="markdownIt-Anchor" href="#step-2-smoothing"></a> Step 2: Smoothing</h5><ul><li>Purpose: Interpolates (inserts) lost readings<br />目的:插入丢失的读数<br />①Temporal interpolation<br />时间插值<br />②Outlier detection<br />异常值检测</li><li>Method: Window based queries<br />方法:基于窗口的查询<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/3.png" alt="Step 2: Smoothing" /></li></ul><h5 id="step-3-merge"><a class="markdownIt-Anchor" href="#step-3-merge"></a> Step 3: Merge</h5><ul><li>Purpose: Spatial interpolation<br />目的:空间插值</li><li>例如:在一个空间颗粒中，通过计算来自不同尘埃的读数的平均值，并忽略偏离平均值两个偏差之外的单个读数。</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/4.png" alt="Step 3: Merge" /></p><h5 id="step-4-arbitrate-仲裁"><a class="markdownIt-Anchor" href="#step-4-arbitrate-仲裁"></a> Step 4: Arbitrate 仲裁</h5><ul><li>Purpose: Remove<br />目的：删除<br />① conflicting readings<br />冲突的读数<br />② de-duplication<br />重复数据删除</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/5.png" alt="Step 4: Arbitrate" /></p><h5 id="step-5-virtualize-虚拟化"><a class="markdownIt-Anchor" href="#step-5-virtualize-虚拟化"></a> Step 5: Virtualize 虚拟化</h5><ul><li>Purpose: Multi-source integration<br />目的:多源集成</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/6.png" alt="Step 5: Virtualize" /></p><h2 id="data-fusion-数据融合"><a class="markdownIt-Anchor" href="#data-fusion-数据融合"></a> Data Fusion 数据融合</h2><ul><li><p>概念（重点）<br />Data fusion combine data from multiple sources and gather that information in order to achieve inferences, which will be more efficient and potentially more accurate than if they were achieved by means of a single source.<br />数据融合将来自多个来源的数据组合起来，并收集这些信息，以实现推断，这将比通过单一来源实现更有效和更准确。</p></li><li><p>填空题<br />Sensors only give <strong>an estimate of the measured physical property</strong><br />传感器只能对测量到的物理性质作出估计。<br /><strong>Nature of errors</strong> often determine the preferred fusion algorithm<br />误差的性质往往决定了融合算法的首选。</p></li></ul><h3 id="three-processing-architectures-三个处理架构"><a class="markdownIt-Anchor" href="#three-processing-architectures-三个处理架构"></a> Three Processing Architectures 三个处理架构</h3><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Data-level fusion</td><td>数据级融合</td></tr><tr><td>Feature-level fusion</td><td>特征级融合</td></tr><tr><td>Decision-level fusion</td><td>决策级融合</td></tr></tbody></table><ul><li>Data-level fusion: Direct fusion of sensor data<br />数据级融合: 传感器数据的直接融合，</li><li>Feature-level fusion: Representation of sensor data via feature vectors, with subsequent fusion of the feature vectors<br />特征级融合: 通过特征向量表示传感器数据，然后融合特征向量</li><li>Decision-level fusion: Processing of each sensor to achieve high-level inferences or decisions, which are subsequently combined.<br />决策级融合 :对每个传感器进行处理，以实现高级推理或决策，然后将这些推理或决策组合在一起。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/7.png" alt="Data Fusion" /></li></ul><h4 id="data-level-fusion"><a class="markdownIt-Anchor" href="#data-level-fusion"></a> Data-level Fusion</h4><ul><li>使用条件:  if the sensors are measuring the same physical phenomena.<br />如果传感器测量的是相同的物理现象</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/8.png" alt="Data-level Fusion" /></p><h2 id="data-storage-数据存储"><a class="markdownIt-Anchor" href="#data-storage-数据存储"></a> Data Storage  数据存储</h2><h3 id="database-system"><a class="markdownIt-Anchor" href="#database-system"></a> Database System</h3><ul><li>Database: collection of persistent data<br />数据库:持久数据的收集</li><li>Data: Known facts that can be recorded and have an implicit meaning.<br />数据:可以记录并具有隐含意义的已知事实。</li><li><strong>Database Management System (DBMS)</strong>: software system that supports creation, population, and querying of a database<br />数据库管理系统(DBMS):支持数据库的创建、填充和查询的软件系统</li><li>Database System: DBMS + Database<br />数据库系统:DBMS +数据库</li></ul><h3 id="dbms-功能"><a class="markdownIt-Anchor" href="#dbms-功能"></a> DBMS 功能</h3><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td>Define</td><td>定义特定的数据库</td></tr><tr><td>Construct</td><td>构造初始数据库</td></tr><tr><td>Manipulate</td><td>增删改查数据库</td></tr><tr><td>Share a database</td><td>数据库共享</td></tr></tbody></table><ul><li>Define a database.<br />根据数据类型、结构和约束定义特定的数据库</li><li>Construct or Load the initial database.<br />在辅助存储介质上构造或加载初始数据库内容</li><li>Manipulate the database:<br />操作数据库:<br />① Retrieval, Modification<br />检索，修改<br />② Accessing the database through Web applications<br />通过Web应用程序访问数据库</li><li>Share a database<br />共享数据库允许多个用户和程序同时访问数据库</li></ul><h3 id="data-storage-solution-数据存储解决方案重点"><a class="markdownIt-Anchor" href="#data-storage-solution-数据存储解决方案重点"></a> Data Storage Solution 数据存储解决方案（重点）</h3><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td>Direct Attached Storage</td><td>直接连接存储器(DAS)</td></tr><tr><td>Network Attached Storage</td><td>网络附加存储(NAS)</td></tr><tr><td>Storage Area Network</td><td>存储区域网络(SAN)</td></tr></tbody></table><ul><li>Direct Attached Storage (DAS)<br />Characteristics: Storage devices attached directly to servers (only point of access)<br />直接连接到服务器的存储设备(仅访问点)</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/9.png" alt="DAS" /></p><ul><li>Network Attached Storage (NAS)<br />Characteristics: more reliable than DAS, limited by LAN bandwidth.</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/10.png" alt="NAS" /></p><ul><li>Storage Area Network (SAN)<br />Characteristics: more expensive<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/11.png" alt="SAN" /></li></ul><h2 id="57-data-mining-数据挖掘"><a class="markdownIt-Anchor" href="#57-data-mining-数据挖掘"></a> 5.7 Data Mining 数据挖掘</h2><h3 id="major-data-mining-tasks-数据挖掘的主要任务"><a class="markdownIt-Anchor" href="#major-data-mining-tasks-数据挖掘的主要任务"></a> Major Data Mining Tasks 数据挖掘的主要任务</h3><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td><strong>Classification</strong></td><td>分类，预测项目类</td></tr><tr><td><strong>Association Rule Discovery</strong></td><td>关联发现</td></tr><tr><td><strong>Clustering</strong></td><td>聚类，查找项目类</td></tr><tr><td>Sequential Pattern Discovery</td><td>顺序模式发现</td></tr><tr><td>Deviation Detection</td><td>偏差检测</td></tr><tr><td>Forecasting</td><td>预测</td></tr><tr><td>Description</td><td>描述</td></tr><tr><td>Link analysis</td><td>寻找联系和关联</td></tr></tbody></table><h4 id="classification-分类"><a class="markdownIt-Anchor" href="#classification-分类"></a> Classification 分类</h4><ul><li><p>定义<br />Find a model for class attribute as a function of the<br />values of other attributes.<br />将class属性作为其他属性值的函数来查找模型。</p></li><li><p>test set 测试集<br />A test set is used to determine the accuracy of the model.<br />测试集用于确定模型的准确性。</p></li><li><p>Classification method 分类方法</p></li></ul><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td>Decision Tree</td><td>决策树</td></tr><tr><td>Naive Bayesian classifiers</td><td>朴素贝叶斯分类器</td></tr><tr><td>Using association rule</td><td>使用关联规则</td></tr><tr><td>Neural networks</td><td>神经网络</td></tr></tbody></table><h4 id="clustering-聚类定义"><a class="markdownIt-Anchor" href="#clustering-聚类定义"></a> Clustering 聚类定义</h4><p>Given a set of data points, each having a set ofattributes, and a <strong>similarity measure</strong> among them.</p><h2 id="58-multimedia-information-processing-多媒体信息处理"><a class="markdownIt-Anchor" href="#58-multimedia-information-processing-多媒体信息处理"></a> 5.8 Multimedia Information Processing 多媒体信息处理</h2><ul><li>定义<br />Multimedia is a combination of text, graphic, sound, animation, and video that is delivered interactively to the user by electronic or digitally manipulated means.<br />多媒体是文本、图形、声音、动画和视频的组合，通过电子或数字操作的方式交互地传递给用户</li></ul><h3 id="digital-image-processing-数字图像处理"><a class="markdownIt-Anchor" href="#digital-image-processing-数字图像处理"></a> Digital Image Processing 数字图像处理</h3><ul><li>Digital Image<br />A digital image is a representation of a two-dimensional image as a finite set of digital values, called picture elements or pixels.<br />数字图像是二维图像的一种表示，它是一组有限的数字值，称为图像元素或像素。</li><li>Pixel values 像素值<br />typically represent <strong>gray levels</strong>, <strong>colours</strong>, <strong>opacities</strong> etc.<br />表示灰度、颜色、不透明度。</li><li>填空：Remember digitization implies that a digital image is an <strong>approximation of a real scene</strong>.</li></ul><h4 id="major-tasks-for-digital-image-processing"><a class="markdownIt-Anchor" href="#major-tasks-for-digital-image-processing"></a> Major tasks for digital Image Processing</h4><ul><li>Improvement of pictorial information for human interpretation.<br />改善图像信息的人类解释。</li><li>Processing of image data for storage, transmission and representation for autonomous machine perception.<br />用于存储、传输和表示自主机器感知的图像数据处理。</li></ul><h4 id="processing-level"><a class="markdownIt-Anchor" href="#processing-level"></a> Processing level</h4><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Information_Processing_for_IoT/12.png" alt="Processing level" /></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireless Sensor Networks of IoT</title>
      <link href="/Wireless%20Sensor%20Networks.html"/>
      <url>/Wireless%20Sensor%20Networks.html</url>
      
        <content type="html"><![CDATA[<h2 id="41-introduction"><a class="markdownIt-Anchor" href="#41-introduction"></a> 4.1 Introduction</h2><h3 id="要背的基本概念"><a class="markdownIt-Anchor" href="#要背的基本概念"></a> 要背的基本概念</h3><ul><li>Sensor node: sensing, data processing, and communicating capacity<br />传感器节点: 感知、数据处理和通信能力</li><li>Sensor network: a large number of sensor nodes that are densely deployed either inside the phenomenon or very close to it<br />传感器网络: 大量的传感器节点密集部署在现象内部或非常接近现象内部</li><li>A wireless sensor network (WSN) consists of spatially distributed autonomous sensors.<br />无线传感器网络(WSN)由空间分布的自主传感器组成</li></ul><h3 id="applications-应用"><a class="markdownIt-Anchor" href="#applications-应用"></a> Applications 应用</h3><table><thead><tr><th>Application</th><th>解释</th></tr></thead><tbody><tr><td>Wildlife Monitor</td><td>野生动物监测</td></tr><tr><td>Ecosystem record</td><td>生态系统记录</td></tr><tr><td>Traffic Monitor</td><td>交通监控</td></tr><tr><td>Building Monitor</td><td>构建监测</td></tr><tr><td>Healthy</td><td>健康</td></tr><tr><td>Military</td><td>军事</td></tr><tr><td>Home</td><td>家居</td></tr><tr><td>Commercial</td><td>商业</td></tr></tbody></table><h3 id="new-design-themes-新设计主题"><a class="markdownIt-Anchor" href="#new-design-themes-新设计主题"></a> New Design Themes 新设计主题</h3><ul><li>Long-lived systems that can be unattended<br />可以无人值守的长寿命系统<br />① Low-duty cycle operation with bounded latency<br />低占空比操作，延迟有限<br />② Exploit redundancy<br />利用冗余<br />③ Tiered architectures (mix of form/energy factors)<br />分层架构(形式/能量因素的混合)</li><li>Self-configuring systems that can be deployed ad hoc<br />可以临时部署的自配置系统<br />① Measure and adapt to unpredictable environment<br />可以临时部署的自配置系统<br />② Exploit spatial diversity and density of sensor/actuator nodes<br />开发传感器/执行器节点的空间多样性和密度</li></ul><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><ul><li>Leverage data processing inside the network<br />利用网络内部的数据处理</li><li>Achieve desired global behavior with adaptive localized algorithms.<br />通过自适应局部化算法</li></ul><h3 id="communication-architecture-通信体系结构"><a class="markdownIt-Anchor" href="#communication-architecture-通信体系结构"></a> Communication Architecture  通信体系结构</h3><table><thead><tr><th>Factors</th><th>解释</th></tr></thead><tbody><tr><td>Fault tolerance</td><td>容错</td></tr><tr><td>Scalability</td><td>可扩展性</td></tr><tr><td>Production costs</td><td>生产成本</td></tr><tr><td>Hardware constraints</td><td>硬件限制</td></tr><tr><td>Network topology</td><td>网络拓补结构</td></tr><tr><td>Transmission media</td><td>传播媒体</td></tr><tr><td>Environment</td><td>环境</td></tr><tr><td>Power consumption</td><td>功耗</td></tr></tbody></table><ul><li><p>Fault Tolerance: The ability to sustain sensor network functionalities without any interruption due to sensor node failures.<br />容错：支持传感器网络功能而不因传感器节点故障而中断的能力。</p></li><li><p>Scalability: The number of sensor nodes<br />可扩展性:传感器节点的数量</p></li><li><p>Production Costs: The cost of a single node is very important to justify the overall cost of the network<br />生产成本:单个节点的成本是非常重要的，以证明整个网络的成本</p></li><li><p>Hardware’s 4 basic unit:</p></li></ul><table><thead><tr><th>basic unit</th><th>解释</th></tr></thead><tbody><tr><td>sensing unit</td><td>传感单元</td></tr><tr><td>processing unit</td><td>处理单元</td></tr><tr><td>transceiver unit</td><td>收发单元</td></tr><tr><td>power unit</td><td>电源单元</td></tr><tr><td>Additional application-dependent units</td><td>更多的依赖于应用程序的单位</td></tr></tbody></table><ul><li>Hardware Constraints</li></ul><table><thead><tr><th>Constraints</th><th>解释</th></tr></thead><tbody><tr><td>size</td><td>大小</td></tr><tr><td>Power</td><td>电量</td></tr><tr><td>Operate in high density</td><td>高集成度</td></tr><tr><td>Low cost</td><td>低成本</td></tr><tr><td>Autonomous</td><td>自动</td></tr><tr><td>Adaptive to environment</td><td>适应环境</td></tr></tbody></table><ul><li>Sensor Network Topology<br />Topology maintenance and change in 3 phases:<br />拓扑维护和变更分3个阶段</li></ul><table><thead><tr><th>phase</th><th>解释</th></tr></thead><tbody><tr><td>Predeployment and deployment phase</td><td>预部署和部署阶段</td></tr><tr><td>Post-deployment phase</td><td>部署后阶段</td></tr><tr><td>Redeployment of additional nodes phase</td><td>额外节点的重新部署阶段</td></tr></tbody></table><ul><li>Transmission Media 传播介质</li></ul><table><thead><tr><th>media</th><th>解释</th></tr></thead><tbody><tr><td>wireless medium</td><td>无线媒体</td></tr><tr><td>Radio</td><td>广播</td></tr><tr><td>Infrared</td><td>红外线</td></tr><tr><td>Optical</td><td>光学</td></tr></tbody></table><h2 id="42-hardware-and-operating-system"><a class="markdownIt-Anchor" href="#42-hardware-and-operating-system"></a> 4.2 Hardware and Operating System</h2><table><thead><tr><th>Name</th><th>具体名称</th></tr></thead><tbody><tr><td>Hardware</td><td>Berkeley Motes</td></tr><tr><td></td><td>System of MICA Motes</td></tr><tr><td></td><td>MICA Motes</td></tr><tr><td></td><td>MICAz</td></tr><tr><td></td><td>TelosB</td></tr><tr><td>Operating System</td><td>TinyOS</td></tr><tr><td></td><td>Contiki</td></tr><tr><td></td><td>LiteOS</td></tr></tbody></table><ul><li>LiteOS is a real-time operating system (RTOS) for use in sensor networks.<br />LiteOS是一个实时操作系统(RTOS)，用于传感器网络。</li><li>memory-constrained 内存受限的</li></ul><h2 id="43-communication-protocols"><a class="markdownIt-Anchor" href="#43-communication-protocols"></a> 4.3  Communication Protocols</h2><ul><li>Design Issues According to Protocol Stack 根据协议栈设计问题</li></ul><table><thead><tr><th>Name</th><th>解释</th></tr></thead><tbody><tr><td>Physical layer</td><td>物理层</td></tr><tr><td>Data link layer</td><td>数据链路层</td></tr><tr><td>Network layer</td><td>网络层</td></tr><tr><td>Transport layer</td><td>传输层</td></tr></tbody></table><ul><li>Three Management Planes 三个管理方面</li></ul><table><thead><tr><th>plane</th><th>解释</th></tr></thead><tbody><tr><td>The power management plane</td><td>电源管理层面</td></tr><tr><td>The mobility management plane</td><td>移动管理层面</td></tr><tr><td>The task management plane</td><td>任务管理层面</td></tr></tbody></table><h2 id="44-important-issues-重要问题"><a class="markdownIt-Anchor" href="#44-important-issues-重要问题"></a> 4.4 Important Issues 重要问题</h2><table><thead><tr><th>Issues</th><th>解释</th></tr></thead><tbody><tr><td>Routing Protocols</td><td>路由协议</td></tr><tr><td>Topology Control</td><td>拓扑控制</td></tr><tr><td>Coverage Problems</td><td>覆盖问题</td></tr><tr><td>Time Synchronization</td><td>时间同步</td></tr><tr><td>Localization</td><td>本地化</td></tr></tbody></table><h3 id="441-routing-protocols-路由协议"><a class="markdownIt-Anchor" href="#441-routing-protocols-路由协议"></a> 4.4.1 Routing Protocols  路由协议</h3><ul><li>Classified based on the underlying network structure:</li></ul><table><thead><tr><th>categories</th><th>解释</th><th>翻译</th></tr></thead><tbody><tr><td><strong>Flat</strong></td><td>Nodes are assigned equal roles</td><td>平面：节点被分配相等的角色</td></tr><tr><td><strong>Hierarchical</strong></td><td>Nodes will play different roles</td><td>分级：节点将扮演不同的角色</td></tr><tr><td>Location-based</td><td>Nodes’ positions are exploited to route data</td><td>基于位置的：节点的位置被用来路由数据</td></tr></tbody></table><h4 id="flat-routing-平面路由协议"><a class="markdownIt-Anchor" href="#flat-routing-平面路由协议"></a> Flat Routing  平面路由协议</h4><table><thead><tr><th>protocol</th><th>翻译</th></tr></thead><tbody><tr><td>Sensor Protocols for Information via Negotiation(SPIN)</td><td>信息协商传感器协议</td></tr><tr><td>Directed diffusion (DD)</td><td>定向扩散</td></tr></tbody></table><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Wireless_Sensor_Networks_of_IoT/1.png" alt="SPIN" /></p><ul><li>DD</li></ul><table><thead><tr><th>feature</th><th>翻译</th></tr></thead><tbody><tr><td>establish path</td><td>建立路径</td></tr><tr><td>Localized interactions</td><td>局部的相互作用</td></tr></tbody></table><table><thead><tr><th>elements</th><th>翻译</th></tr></thead><tbody><tr><td>Interest</td><td>感兴趣</td></tr><tr><td>Gradient</td><td>梯度</td></tr><tr><td>Data message</td><td>数据信息</td></tr><tr><td>Reinforcement</td><td>强化</td></tr></tbody></table><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Wireless_Sensor_Networks_of_IoT/2.png" alt="DD" /></p><h4 id="hierarchical-routing-分级路由协议"><a class="markdownIt-Anchor" href="#hierarchical-routing-分级路由协议"></a> Hierarchical Routing 分级路由协议</h4><ul><li>Advantages</li></ul><table><thead><tr><th>advantages</th><th>翻译</th></tr></thead><tbody><tr><td>scalability</td><td>可伸缩性</td></tr><tr><td>efficient communication</td><td>有效沟通</td></tr></tbody></table><ul><li>Mainly two-layer routing</li></ul><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Select cluster heads</td><td>选择集群头</td></tr><tr><td>Routing</td><td>路由</td></tr></tbody></table><h3 id="442-topology-control-拓扑控制"><a class="markdownIt-Anchor" href="#442-topology-control-拓扑控制"></a> 4.4.2 Topology Control  拓扑控制</h3><ul><li><p>定义<br />Topology control is a technique used in distributed computing to alter the underlying network (modeled as a graph) in order to reduce the cost of distributed algorithms if ran over the new resulting graphs.<br />拓扑控制是一种用于分布式计算的技术，用于改变底层网络(建模为一个图)，以便在运行新的结果图时降低分布式算法的成本。</p></li><li><p>Subproblem of Topology control</p></li></ul><table><thead><tr><th>Name</th><th>翻译</th><th>解释</th></tr></thead><tbody><tr><td>topology construction</td><td>拓扑结构</td><td></td></tr><tr><td>topology maintenance</td><td>拓扑维护</td><td>connectivity and coverage are preserved</td></tr></tbody></table><ul><li>Topology construction<br />increase the number of message collisions<br />将增加消息冲突的数量</li><li>Topology maintenance<br />nodes that are closer to the sink spend higher amounts of energy.<br />距离接收器越近的节点消耗的能量越高</li></ul><h3 id="443-coverage-problems-覆盖问题"><a class="markdownIt-Anchor" href="#443-coverage-problems-覆盖问题"></a> 4.4.3 Coverage Problems 覆盖问题</h3><ul><li><p>Goal<br />each location in the targeted physical space should be within sensing range of at least one sensor.<br />目标物理空间中的每个位置应在至少一个传感器的传感范围内。</p></li><li><p>Simple Coverage Problem: entire area covered. 全覆盖</p></li><li><p>K-Coverage Problem:  entire region k-covered. 全被k次覆盖</p></li><li><p>Types<br />Area Coverage: cover/monitor an area/region.<br />区域覆盖:覆盖/监测一个区域/区域。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Wireless_Sensor_Networks_of_IoT/3.png" alt="Area Coverage" /></p></li></ul><p>Point Coverage: cover a set of points.<br />点覆盖:覆盖一组点。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Wireless_Sensor_Networks_of_IoT/4.png" alt="Point Coverage" /></p><p>Barrier Coverage:minimize the probability of undetected penetration through the barrier (sensor network).<br />屏障覆盖:最小化未检测到的穿透屏障(传感器网络)的概率。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Wireless_Sensor_Networks_of_IoT/5.png" alt="Barrier Coverage" /></p><h3 id="444-time-synchronization-时间同步"><a class="markdownIt-Anchor" href="#444-time-synchronization-时间同步"></a> 4.4.4 Time Synchronization  时间同步</h3><ul><li>Several issues in synchronization 同步上的一些问题</li></ul><ol><li><p>Master-slave v.s. peer-to-peer synchronization</p><ul><li>Master-slave 主从<br />attempt to synchronize with the master. 子节点与主节点同步</li><li>Peer-to-peer 点对点<br />estimates the local time based on the clocks of other nodes<br />通过通信估计出时间</li></ul></li><li><p>Internal synchronization v.s. external synchronization</p><ul><li><p>Internal synchronization<br />minimize the maximum difference between the readings of local clocks of the sensors<br />最小化传感器的本地时钟读数之间的最大差异</p></li><li><p>External synchronization<br />A standard external source of time<br />标准的外部时间源</p></li></ul></li></ol><h3 id="445-localization-本地化"><a class="markdownIt-Anchor" href="#445-localization-本地化"></a> 4.4.5 Localization 本地化</h3><ul><li>To determine the physical coordinates of a group of sensor nodes in a wireless sensor network (WSN).<br />确定无线传感器网络(WSN)中一组传感器节点的物理坐标。</li><li>Due to application context and massive scale, use of GPS is unrealistic, therefore, sensors need to self-organize a coordinate system.<br />由于应用环境和大规模，使用GPS是不现实的，因此，传感器需要自组织一个坐标系统。</li><li>To report data that is geographically meaningful<br />报告具有地理意义的数据</li><li>Services such as routing rely on location information;  geographic routing protocols; context-based routing protocols, location-aware services<br />路由等服务依赖于位置信息;地理路由协议;基于上下文的路由协议，位置感知服务</li></ul><h4 id="dv-hop-phase-1-dv-hop阶段1"><a class="markdownIt-Anchor" href="#dv-hop-phase-1-dv-hop阶段1"></a> DV-hop Phase 1  DV-hop阶段1:</h4><h4 id="euclidean-phase-1-欧几里得阶段1"><a class="markdownIt-Anchor" href="#euclidean-phase-1-欧几里得阶段1"></a> Euclidean Phase 1: 欧几里得阶段1:</h4><p>研究一下</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Networking Technologies of IoT</title>
      <link href="/Networking%20Technologies%20of%20IoT.html"/>
      <url>/Networking%20Technologies%20of%20IoT.html</url>
      
        <content type="html"><![CDATA[<h2 id="31-computer-network-and-internet-计网"><a class="markdownIt-Anchor" href="#31-computer-network-and-internet-计网"></a> 3.1 Computer Network and Internet 计网</h2><h3 id="computer-network"><a class="markdownIt-Anchor" href="#computer-network"></a> Computer Network</h3><ul><li>Defination: group of interconnected computers.</li><li>Computer Network allows computers to communicate with each other and to share resources and information.</li></ul><h3 id="communication-model-通信模型"><a class="markdownIt-Anchor" href="#communication-model-通信模型"></a> Communication Model 通信模型</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/1.png" alt="Communication Model" /></p><table><thead><tr><th>name</th><th>作用</th></tr></thead><tbody><tr><td>Source</td><td>生成要传输的数据</td></tr><tr><td>Transmitter</td><td>将数据转换成可传输的信号</td></tr><tr><td>Transmission System</td><td>传输信号</td></tr><tr><td>Receiver</td><td>将接收到的信号转换成数据</td></tr><tr><td>Destination</td><td>接收数据</td></tr></tbody></table><h3 id="communication-types-通信类型"><a class="markdownIt-Anchor" href="#communication-types-通信类型"></a> Communication Types 通信类型</h3><table><thead><tr><th>name</th><th>名字</th><th>特点</th></tr></thead><tbody><tr><td>Unicasting</td><td>单播</td><td>一对一</td></tr><tr><td>Multicasting</td><td>多播</td><td>一对多</td></tr><tr><td>Broadcasting</td><td>广播</td><td>一对范围内所有</td></tr></tbody></table><h3 id="network-classification"><a class="markdownIt-Anchor" href="#network-classification"></a> Network Classification</h3><h4 id="classify-with-area"><a class="markdownIt-Anchor" href="#classify-with-area"></a> classify with area</h4><ul><li>WAN &gt; MAN &gt; LAN &gt; PAN</li></ul><table><thead><tr><th>name</th><th>名字</th><th>特点</th></tr></thead><tbody><tr><td>PAN</td><td>个人区域网</td><td>10米以内</td></tr><tr><td>LAN</td><td>局域网</td><td>对范围有限制，对传输时间有要求</td></tr><tr><td>MAN</td><td>城域网</td><td>大范围，50km，大型局域网</td></tr><tr><td>WAN</td><td>广域网</td><td>互联网就是广域网，通常涵盖一个国家或一个洲</td></tr></tbody></table><h3 id="classify-with-connectivity-method-按联通方式算法分类"><a class="markdownIt-Anchor" href="#classify-with-connectivity-method-按联通方式算法分类"></a> classify with connectivity method 按联通方式（算法）分类</h3><table><thead><tr><th>name</th><th>cost</th><th>install</th><th>troubleshoot</th><th>check</th><th>other</th></tr></thead><tbody><tr><td>BUS</td><td>low</td><td>easy</td><td>easy</td><td>hard</td><td></td></tr><tr><td>STAR</td><td>high</td><td>easy</td><td>hard</td><td>easy</td><td>HUB成本高</td></tr><tr><td>MESH</td><td>high</td><td>easy</td><td>hard</td><td>easy</td><td></td></tr><tr><td>TREE</td><td>middle</td><td>hard</td><td>easy</td><td>hard</td><td>点对点连接，有软件支持</td></tr></tbody></table><ol><li>BUS<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/2.png" alt="BUS" /></li></ol><p>所有网络中的设施都作为主干路的节点，所有设施只能向左或向右传输。</p><ul><li>优点：① 易安装 ② 电缆成本低</li><li>缺点：① 一点故障网络崩溃 ② 难检查故障</li></ul><ol start="2"><li>STAR<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/3.png" alt="STAR" /></li></ol><p>所有设施均通过一个HUB连接，HUB掌管一切</p><ul><li>优点：① 易安装 ② 故障不会影响整个网络 ③ 易检查故障</li><li>缺点：① 电缆成本高 ② HUB崩溃网络崩溃 ③ HUB成本高</li></ul><ol start="3"><li>MESH<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/4.png" alt="MESH" /><br />用电缆去连接每个其他设备</li></ol><ul><li>优点：容忍节点崩溃，易安装</li><li>缺点：成本高</li></ul><ol start="4"><li>TREE<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/5.png" alt="TREE" /></li></ol><ul><li>优点： 点对点连接，有软硬件支持</li><li>缺点：有电缆类型限制，不容忍节点崩溃， 难安装</li></ul><h3 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h3><table><thead><tr><th>name</th><th>名字</th><th>特点</th></tr></thead><tbody><tr><td>Intranet</td><td>内部网</td><td>单一管理实体</td></tr><tr><td>Extranet</td><td>外部网</td><td>对外界访问有限制</td></tr><tr><td>Internet 互联网</td><td>全世界靠协议互通</td><td></td></tr></tbody></table><h3 id="网络用语定义"><a class="markdownIt-Anchor" href="#网络用语定义"></a> 网络用语定义</h3><p>Packet： 网络传输包<br />Point- to - Point network: 点对点网络<br />Router： 路由器，负责在两个网络之间传输信息。</p><h3 id="网络传输方式"><a class="markdownIt-Anchor" href="#网络传输方式"></a> 网络传输方式</h3><ul><li>circuit switching: dedicated circuit per call 电路传输</li><li>packet switching: data sent through net in discrete “chunks”   以包的形式分块传输</li></ul><h3 id="protocol-协议重点"><a class="markdownIt-Anchor" href="#protocol-协议重点"></a> Protocol 协议（重点）</h3><ul><li>定义<br />A protocol is a set of rules that governs the communications between computers on a network.<br />协议是控制网络上计算机之间通信的一组规则。</li></ul><h4 id="协议的关键特征"><a class="markdownIt-Anchor" href="#协议的关键特征"></a> 协议的关键特征</h4><ul><li>制定数据交换的格式</li><li>Syntax: 数据格式</li><li>Semantics: 控制信息(匹配判定，错误判定等）</li><li>Timing: 传输速度匹配，排队传输</li><li>Actions: 如果发生了事情的处理办法</li></ul><h4 id="协议栈相关基本属于重点"><a class="markdownIt-Anchor" href="#协议栈相关基本属于重点"></a> 协议栈相关基本属于（重点）</h4><ul><li>Reliability 数据可靠性<br />error-free &amp; ordered delivery 无误差，无乱序<br />保证措施：acknowledgements and retransmission  确认和重传</li><li>Overload 过载<br />Too many packets occur in a subnetwork in the same time<br />太多包出现在一个子网络中导致处理效率降低或堵塞</li><li>Congestion 堵塞<br />路由器队列太长，导致缓存满了，造成数据堵塞。</li><li><strong>Flow-control 流量控制</strong><br />to protect the receiver against the overload<br /><strong>防止过载，传输层关键算法</strong></li><li><strong>Congestion prevention 防堵塞</strong><br />to prevent the intermediate nodes against the overload<br /><strong>防止中间节点过载，网络层关键算法</strong></li><li>End-to-end 端到端<br />终端到终端。</li></ul><h4 id="osi-protocal-stack-osi协议栈-重点"><a class="markdownIt-Anchor" href="#osi-protocal-stack-osi协议栈-重点"></a> OSI Protocal Stack   OSI协议栈 （重点）</h4><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/6.png" alt="OSI Model" /></p><ol><li><strong>Physical Layer</strong> 物理层</li></ol><ul><li>信号以能量的形式在媒介中传输。</li></ul><ol start="2"><li><strong>(Data) Link Layer</strong> 链路层</li></ol><ul><li><strong>correct errors.</strong></li><li>将字节电流（bits）转化为传输帧（Transmission of frames）</li><li>error contorl &amp; flow control</li></ul><ol start="3"><li><strong>Network Layer</strong> 网络层</li></ol><ul><li>主要负责节点之间的链接</li><li>End-to-end packet transmission</li><li>Congestion control</li></ul><ol start="4"><li>Transport Layer 传输层</li></ol><ul><li>End-to-end packet reliablility</li><li>把整条消息分成包去发送</li><li>Reassemble 将包重新集合</li><li>End-to-end flow control</li><li>Acknowledgments 信息确认</li></ul><ol start="5"><li>Session Layer 会话层</li></ol><ul><li>session management service 会话管理服务协议</li><li>Assignment of logical ports 逻辑端口的分配</li><li>Synchronization 异步</li></ul><ol start="6"><li>Presentation Layer 表现层</li></ol><ul><li>syntax and semantics of messages</li><li>code conversion</li></ul><ol start="7"><li>Application Layer 应用层</li></ol><ul><li><p>用户网络应用协议</p></li><li><p>协议栈性质:<br />Each layer in stack:</p></li></ul><ol><li>Performs related functions<br />执行相关功能</li><li>Relies on lower layer for more primitive functions<br />依赖于更低级的功能</li><li>Provides services to next higher layer<br />为下一层提供服务</li><li>Communicates with corresponding peer layer of neighboring system using a protocol<br />利用协议与邻近系统的相应对等层通信</li></ol><h4 id="传输协议的可靠性"><a class="markdownIt-Anchor" href="#传输协议的可靠性"></a> 传输协议的可靠性</h4><p>传输层协议：</p><ul><li>TCP：可靠传输</li><li>UDP：不可靠传输</li></ul><h3 id="网络设备-重点"><a class="markdownIt-Anchor" href="#网络设备-重点"></a> 网络设备 （重点）</h3><table><thead><tr><th>name</th><th>名字</th><th>特点</th></tr></thead><tbody><tr><td><strong>Repeater</strong></td><td>中继器</td><td>将网络逻辑上连接到一起</td></tr><tr><td><strong>Hub</strong></td><td>中心</td><td>多端口的中继器</td></tr><tr><td>Bridge</td><td>网桥</td><td>两个网络的数据连接</td></tr><tr><td>Switch</td><td>开关</td><td>多端口的网桥</td></tr><tr><td>Router</td><td>路由器</td><td>连接在传输层兼容的网络</td></tr><tr><td>Gateway (proxy server)</td><td>网关（代理服务器）</td><td>连接两个网络之间的路由器</td></tr></tbody></table><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Networking_Technologies_of_IoT/7.png" alt="Devices of the Network Connection" /></p><h2 id="packet-switching-circuit-switching"><a class="markdownIt-Anchor" href="#packet-switching-circuit-switching"></a> Packet Switching &amp; Circuit Switching</h2><h3 id="packet-swithching-分组交换-不重要"><a class="markdownIt-Anchor" href="#packet-swithching-分组交换-不重要"></a> Packet Swithching 分组交换 （不重要）</h3><ul><li>适用于传输数据量大的情况</li><li>适用场景<ul><li>资源分享</li><li>没有 start-up delay 的场景</li></ul></li><li>包传输需要经历时延，所以不能用于实时传输</li><li>过度拥堵会导致包的延迟和丢失</li><li>协议需要实现数据传输和拥塞控制</li></ul><h4 id="分组交换的性能-不重要"><a class="markdownIt-Anchor" href="#分组交换的性能-不重要"></a> 分组交换的性能 （不重要）</h4><ul><li>性能指标<br />Overhead 开支：CPU把包放在网络上所需要的时间<br />Throughput 吞吐量: 每秒传输的最大字节数<br />Latency 延迟：第一个字节到达接收方所需要的时间</li><li>延迟来源<br />Wire latency 线路延迟<br />Router latency 路由器延迟</li></ul><h4 id="分组交换的延迟来源-不重要"><a class="markdownIt-Anchor" href="#分组交换的延迟来源-不重要"></a> 分组交换的延迟来源 （不重要）</h4><ul><li>Nodal processing 节点处理</li><li>Queuing 队列</li><li>Transmission delay 传输延迟</li><li>Propagation delay 传播延迟</li></ul><h3 id="internet-protocal"><a class="markdownIt-Anchor" href="#internet-protocal"></a> Internet protocal</h3><ul><li>Application Layer: ftp,smtp,http</li><li>Transport Layer: tcp,udp</li><li>Network Layer: ip,routing protocal</li></ul><h2 id="mobile-communication-network"><a class="markdownIt-Anchor" href="#mobile-communication-network"></a> Mobile Communication Network</h2><ul><li>First-generation mobile phones: analog voice<ul><li>IMTS (Improved Mobile Telephone System)</li><li>AMPS  (Advanced Mobile Phone System)</li></ul></li><li>Second-generation mobile phones: digital voice<ul><li>D-AMPS</li><li>GMS</li><li>CDMA</li></ul></li></ul><h3 id="first-generation-mobile-phones-analog-voice"><a class="markdownIt-Anchor" href="#first-generation-mobile-phones-analog-voice"></a> First-generation mobile phones: analog voice</h3><ul><li>A single channel for both sending and receiving</li><li>Two frequencies</li></ul><h3 id="cellular-network-细胞网络"><a class="markdownIt-Anchor" href="#cellular-network-细胞网络"></a> Cellular Network 细胞网络</h3><ul><li>Each served by its own antenna<br />每个都有自己的天线</li><li>Served by base station consisting of transmitter, receiver, and control unit<br />由发射机、接收机和控制单元组成的基站提供服务</li><li>Band of frequencies allocated Cells set up such that antennas of all neighbors are equidistant (hexagonal pattern)<br />频率频带分配单元的设置使得所有邻居的天线都是等距的(六角形图案)</li><li>To add more users, smaller cells (microcells) are used.<br />为了添加更多的用户，使用了更小的单元(微单元)</li></ul><h3 id="broad-band-wireless-network"><a class="markdownIt-Anchor" href="#broad-band-wireless-network"></a> Broad Band Wireless Network</h3><ul><li>Goals for wireless LAN  无线局域网的目标</li></ul><table><thead><tr><th>Goals</th><th>翻译</th></tr></thead><tbody><tr><td>low power</td><td>低功率</td></tr><tr><td>robust transmission technology</td><td>健壮的传输技术</td></tr><tr><td>easy to use, simple management</td><td>管理简单，易于使用</td></tr><tr><td>protection of investment in wired networks</td><td>有线网络投资保障</td></tr><tr><td>security, privacy</td><td>安全，隐私</td></tr><tr><td>transparency concerning applications and higher layer protocols</td><td>应用协议和更高层协议的透明性</td></tr></tbody></table><ul><li>wireless LAN 优缺点</li></ul><table><thead><tr><th>Advantages</th><th>翻译</th></tr></thead><tbody><tr><td>flexibility</td><td>灵活性</td></tr><tr><td>no wiring difficulties</td><td>没有布线困难</td></tr><tr><td>more robust against disasters</td><td>更强大的御灾能力</td></tr></tbody></table><table><thead><tr><th>DisAdvantages</th><th>翻译</th></tr></thead><tbody><tr><td>lower bitrate compared to wired networks</td><td>与有线网络相比，比特率更低</td></tr><tr><td>More difficult to secure</td><td>更难以获得</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sensing Technologies of IoT</title>
      <link href="/Sensing%20Technology%20of%20IoT.html"/>
      <url>/Sensing%20Technology%20of%20IoT.html</url>
      
        <content type="html"><![CDATA[<h2 id="21-one-dimensional-barcode-一维条形码"><a class="markdownIt-Anchor" href="#21-one-dimensional-barcode-一维条形码"></a> 2.1 One-dimensional Barcode 一维条形码</h2><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/1.png" alt="One-dimensional Barcode" /></p><h3 id="barcode-工作原理"><a class="markdownIt-Anchor" href="#barcode-工作原理"></a> BarCode 工作原理</h3><ul><li>optical machine-readable representation of data.<br />相关的数据的光学机器可读表示法.</li><li>varying the widths and spacings of parallel lines.<br />改变平行线的宽度和间距来表示数据的.</li><li>Each character is represented by a pattern of wide and narrow bars.<br />每一个字母是用一条细线代表的。</li><li>As it moves, barcode reader uses a photosensor to convert the barcode into an <strong>electrical signal</strong>.<br />在扫描器移动过程中其能把条码变成电子信号。</li><li>Every barcode begins with a special <strong>start character</strong> and ends with a special <strong>stop character</strong>.<br />每个条形码都以一个特殊的开始字符开始，以一个特殊的结束字符结束。</li><li>Some barcodes may include a <strong>checksum character</strong> just before the stop character.<br />有些条形码可能在停止字符之前包含校验和字符。</li></ul><h3 id="barcode-具体形式"><a class="markdownIt-Anchor" href="#barcode-具体形式"></a> BarCode 具体形式</h3><table><thead><tr><th>name</th><th>特点 1</th><th>特点2</th></tr></thead><tbody><tr><td><strong>UPC-A</strong></td><td>for product</td><td></td></tr><tr><td>UPC-E</td><td>small items</td><td>automatically re-inserting</td></tr><tr><td>Codabar</td><td>for libraries, blood banks</td><td></td></tr><tr><td><strong>EAN-13</strong></td><td>marking retail goods</td><td>countrycodes</td></tr><tr><td>Interleaved 2 of 5</td><td>for warehouse and industries</td><td></td></tr><tr><td>Code 39</td><td>for government and industries</td><td></td></tr><tr><td>Code 93</td><td>more compact version of Code 39</td><td></td></tr><tr><td>Code 128</td><td>excellent density</td><td>support all ASCII symbols</td></tr><tr><td><strong>Bookland EAN</strong></td><td>for books, video, audio and software</td><td></td></tr></tbody></table><ul><li><p><strong>UPC-A</strong></p><ul><li>identifies the manufacturer and specific product<br />识别制造商和具体的产品<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/2.png" alt="UPC-A" /></li></ul></li><li><p>UPC-E</p><ul><li>for labeling small items</li><li>automatically re-inserting them at the scanner<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/3.png" alt="UPC-E" /></li></ul></li><li><p>Codabar</p><ul><li>for libraries, blood banks<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/4.png" alt="Codabar" /></li></ul></li><li><p><strong>EAN-13</strong></p><ul><li>for marking retail goods. 零售商品</li><li>2 or 3 characters countrycodes + 9 or 10 data digits + 1 checksum<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/5.png" alt="EAN-13" /></li></ul></li><li><p>Interleaved 2 of 5</p><ul><li>for warehouse(仓库) and industries</li></ul></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/6.png" alt="Interleaved 2 of 5" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/7.png" alt="Interleaved 2 of 5" /></p><ul><li>Code 39<ul><li>for government and industries</li></ul></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/8.png" alt="Code 39" /></p><ul><li>Code 93<ul><li>more compact（紧凑） version of Code 39</li></ul></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/9.png" alt="Code 93" /></p><ul><li>Code 128<ul><li>excellent density for all-numeric data and good density for alphanumeric data.<br />对全数字和字母的数据有很好的密度</li><li>support all ASCII symbols</li></ul></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/10.png" alt="Code 128" /></p><ul><li><strong>Bookland EAN (ISBN)</strong><ul><li>for books, video, audio and software<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/11.png" alt="Bookland EAN" /></li></ul></li></ul><h3 id="barcode-reader-工作原理"><a class="markdownIt-Anchor" href="#barcode-reader-工作原理"></a> BarCode Reader 工作原理</h3><ul><li>light source, a lens and a light sensor translating optical impulses into electrical ones.<br />光源、透镜和光传感器将光脉冲转换成电脉冲。</li><li>contain decoder circuitry  译码器电路</li></ul><h3 id="barcode-reader-具体形式不重要"><a class="markdownIt-Anchor" href="#barcode-reader-具体形式不重要"></a> BarCode Reader 具体形式（不重要）</h3><table><thead><tr><th>BarCode Reader Type</th><th>特点</th></tr></thead><tbody><tr><td>Pen-type readers</td><td>light source and photodiode</td></tr><tr><td>Laser scanners</td><td>laser beam &amp; mirror</td></tr><tr><td>CCD readers</td><td>light sensors</td></tr><tr><td>Camera-based readers</td><td>camera and image processing</td></tr><tr><td>Omni-directional barcode scanners</td><td>Laser scanner, for grocery</td></tr></tbody></table><ul><li>Pen-type readers: consist of a light source and photodiode 光源和光电二极管</li><li>Laser scanners: laser beam 激光 mirror 棱镜反射扫描</li><li>CCD readers:  light sensors 光传感器</li><li>Camera-based readers: camera and image processing</li><li>Omni-directional barcode scanners(全方位的条形码扫描仪):  Laser scanner, for grocery</li></ul><h3 id="barcode-system"><a class="markdownIt-Anchor" href="#barcode-system"></a> BarCode System</h3><ul><li>encoding module for generating a visually significant barcode<br />生成具有视觉意义的条形码</li><li>decoding module for receiving an acquired version of a visually significant barcode<br />接收可能在典型的文档处理通道</li><li>recovering the message<br />恢复</li></ul><h2 id="22-two-dimentional-code"><a class="markdownIt-Anchor" href="#22-two-dimentional-code"></a> 2.2 Two-dimentional Code</h2><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><ul><li>encode <strong>a lot of information</strong> in a small space</li><li>contain 100 to about 2000 characters</li></ul><h3 id="具体形式"><a class="markdownIt-Anchor" href="#具体形式"></a> 具体形式</h3><ul><li><p>PDF-417<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/12.png" alt="PDF-417" /></p></li><li><p>DataMatrix<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/13.png" alt="DataMatrix" /></p></li><li><p>QR Code<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/14.png" alt="QRCode" /></p></li></ul><h2 id="23-ic-card"><a class="markdownIt-Anchor" href="#23-ic-card"></a> 2.3 IC card</h2><h3 id="工作原理-2"><a class="markdownIt-Anchor" href="#工作原理-2"></a> 工作原理</h3><ul><li>embedded integrated circuits<br />嵌入式集成电路</li><li>provide identification, authentication, data storage and application processing.<br />识别、认证、数据存储和应用程序处理。</li></ul><h3 id="具体形式-2"><a class="markdownIt-Anchor" href="#具体形式-2"></a> 具体形式</h3><ul><li><p>smart card<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/15.png" alt="smart card" /></p></li><li><p>chip card<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/16.png" alt="chip card" /></p></li><li><p>integrated circuit card<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/17.png" alt="integrated circuit card" /></p></li></ul><h3 id="contact-smart-cards-工作原理"><a class="markdownIt-Anchor" href="#contact-smart-cards-工作原理"></a> Contact smart cards 工作原理</h3><ul><li>comprising gold plated contact pads<br />包括若干镀金接触垫</li><li>power is supplied by the card reader.<br />电源由读卡器提供</li></ul><h3 id="contactless-smart-cards-工作原理-重点"><a class="markdownIt-Anchor" href="#contactless-smart-cards-工作原理-重点"></a> <strong>Contactless smart cards 工作原理 (重点)</strong></h3><ul><li>RF induction technology 无线射频技术</li><li>not have an internal power source 没电</li><li>communicate with a terminal via radio waves<br />通过无线电波与终端通信</li><li>Contactless smart cards do not contain an ordinary readonly RFID, but they do contain a <strong>re-writeable smart card.</strong><br />非接触式智能卡不包含普通的只读RFID，但它们包含可重写的智能卡</li><li>used for identification,authentication, and data storage<br />可用于识别、认证和数据存储</li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><ul><li>Financial: ATM cards, fuel cards, mobile phone SIMs.</li><li>Identifications: driver’s license system, students card</li><li>Healthcare: portable medical record</li></ul><h2 id="24-rfid"><a class="markdownIt-Anchor" href="#24-rfid"></a> 2.4 RFID</h2><h3 id="定义和特点"><a class="markdownIt-Anchor" href="#定义和特点"></a> 定义和特点</h3><ul><li>RFID Radio Frequency Identification：Radio-frequency identification is the use of a wireless non-contact system that uses radio-frequency electromagnetic fields to transfer data from a tag attached to an object, for the purposes of automatic identification and tracking.<br />射频识别:射频识别是使用无线非接触系统，利用射频电磁场将数据从附着在物体上的标签传输到物体上，以实现自动识别和跟踪。</li><li>An ADC (Automated Data Collection) technology<ul><li>uses radio-frequency waves to transfer data to <strong>identify</strong>, <strong>categorize</strong>, <strong>track</strong></li><li><strong>fast</strong> and doesn’t require <strong>physical sight</strong> or <strong>contact</strong></li><li>automatic</li><li>low cost</li><li>unique identification</li></ul></li></ul><h3 id="rfid-组件"><a class="markdownIt-Anchor" href="#rfid-组件"></a> RFID 组件</h3><ul><li>RFID tag</li><li>RF Antenna</li><li>Network</li><li>WorkStation<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/18.png" alt="RFID Components" /></li></ul><h4 id="rfid-tag"><a class="markdownIt-Anchor" href="#rfid-tag"></a> RFID tag</h4><ul><li>The tag contains electronically stored information.<br />标签包含电子存储的信息，可以从几米(码)外读取</li><li>the tag does not need to be within line of sight of the reader.<br />标签不需要在阅读器的视线范围内</li><li>Tags can be read-only or read-write</li></ul><h5 id="rfid-tag-概念图"><a class="markdownIt-Anchor" href="#rfid-tag-概念图"></a> RFID Tag 概念图</h5><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/19.png" alt="RFID" /></p><table><thead><tr><th>name</th><th>名字</th></tr></thead><tbody><tr><td>Antenna</td><td>天线</td></tr><tr><td>Power Supply</td><td>电力供应</td></tr><tr><td>Tx Modulator</td><td>Tx调制器</td></tr><tr><td>Rx Modulator</td><td>Rx调制器</td></tr><tr><td>Control Logic</td><td>逻辑控制模块</td></tr><tr><td>Memory Cells</td><td>记忆模块</td></tr></tbody></table><h5 id="rfid-tag-分类重点"><a class="markdownIt-Anchor" href="#rfid-tag-分类重点"></a> RFID Tag 分类（重点）</h5><table><thead><tr><th>Type</th><th>Battery</th><th>Range</th><th>其他特点</th></tr></thead><tbody><tr><td>Passive</td><td>non-exist</td><td>Short</td><td>reflects radio signal</td></tr><tr><td>Semi-active</td><td>exist</td><td></td><td></td></tr><tr><td>Active</td><td>exist</td><td>High</td><td>Tag actively transmits radio signal</td></tr></tbody></table><table><thead><tr><th>Type</th><th>Change</th></tr></thead><tbody><tr><td>Read-only tags</td><td>never</td></tr><tr><td>Write once</td><td>once</td></tr><tr><td>Read/Write tags</td><td>over time</td></tr></tbody></table><ul><li><p>Passive 被动</p><ul><li>Operational power scavenged from reader radiated power<br />从读出器辐射功率中清除的操作功率</li><li>Tag reflects radio signal from reader<br />标签反射来自阅读器的无线电信号</li><li>Reader powered</li><li>Shorter Read Range</li></ul></li><li><p>Semi-active 半主动</p><ul><li>Operational power provided by battery</li></ul></li><li><p>Active 主动</p><ul><li>Operational power provided by battery - transmitter built into tag<br />工作电源由内置在标签内的电池发射器提供</li><li>Tag transmits radio signal<br />标签传送无线电信号</li><li>Battery powered memory, radio &amp; circuitry<br />电池供电的存储器，无线电和电路</li><li>High Read Range</li></ul></li><li><p>Read-only tags</p></li><li><p>Write once, read many tags</p></li><li><p>Read/Write tags</p></li></ul><h4 id="rfid-reader-重点"><a class="markdownIt-Anchor" href="#rfid-reader-重点"></a> RFID Reader （重点）</h4><ul><li>功能</li></ul><ol><li>Remote power tags  远程电源标签</li><li>Establish a bidirectional data link 建立双向数据链路</li><li>Inventory tags, filter results 库存标签，过滤结果</li><li>Communicate with networked server(s)  与联网的伺服器通讯</li><li>Can read 100-300 tags per second 每秒可以读取100-300个标签</li></ol><h5 id="frequencies-of-operations-for-readers"><a class="markdownIt-Anchor" href="#frequencies-of-operations-for-readers"></a> Frequencies of operations for Readers</h5><table><thead><tr><th>Type</th><th>Frequency</th><th>Speed</th><th>Range</th><th>Penteates</th><th>Antennas Scale</th><th>Construction</th></tr></thead><tbody><tr><td>Low-Frequency</td><td>30-300 kHz</td><td>slow</td><td>minimal</td><td>well except iron</td><td>Large</td><td>thick &amp; complex &amp; expensive</td></tr><tr><td>High-Frequency</td><td>3-30 kHz</td><td>mid-slow</td><td>0.7m</td><td>well except iron</td><td>Large</td><td>thin</td></tr><tr><td>Ultra High Frequency</td><td>300 MHz - 1GHz</td><td>fast</td><td>&gt;1.0m</td><td>well in iron except else</td><td>Smaller</td><td>thinner</td></tr><tr><td>Microwave</td><td>2-30 GHz</td><td>very fast</td><td>greater</td><td>well in iron</td><td>Smaller</td><td>thinner</td></tr></tbody></table><h4 id="rfid-交流模型重点"><a class="markdownIt-Anchor" href="#rfid-交流模型重点"></a> RFID 交流模型（重点）</h4><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/20.png" alt="communication" /></p><ul><li>Host 发出命令</li><li>Reader 和 Tag 通过射频信号进行通信</li><li>Reader 产生 Carrier signal</li><li>Reader通过 Antennas 发送 Carrier signal</li><li>Carrier signal hit Tag</li><li>Tag recieves 并修改信号发送回Reader</li><li>Antennas 接收并发送到 Reader</li><li>Reader decode</li><li>Reader 发送结果到 Host</li></ul><h4 id="electronic-product-code-epc码"><a class="markdownIt-Anchor" href="#electronic-product-code-epc码"></a> Electronic Product Code EPC码</h4><ul><li>universal identifier 通用标识符</li><li>RFID tag</li><li>EPCglobal Tag Data Standard<br />其结构定义在EPCglobal标签数据标准中</li></ul><h4 id="epc-network-ppt-要求理解"><a class="markdownIt-Anchor" href="#epc-network-ppt-要求理解"></a> EPC Network (PPT 要求理解)</h4><ul><li><p>定义<br />The EPCglobal Network is a computer network used to share product data between trading partners. It was created by EPCglobal.<br />EPCglobal网络是一个用于在贸易伙伴之间共享产品数据的计算机网络。它是由EPCglobal创建的。</p></li><li><p>The EPCglobal Network consists of the following components:</p></li></ul><table><thead><tr><th>Name</th><th>翻译</th></tr></thead><tbody><tr><td>Object Naming Service (ONS)</td><td>对象命名服务(ONS)</td></tr><tr><td>EPC Discovery Services</td><td>EPC发现服务</td></tr><tr><td>EPC Information Services (EPCIS)</td><td>EPC信息服务(EPCIS)</td></tr></tbody></table><h2 id="25-sensor"><a class="markdownIt-Anchor" href="#25-sensor"></a> 2.5 Sensor</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>A device that responds to a physical stimulus and transmits a resulting impulse.</p><p>A sensor is a converter that measures a physical quantity and converts it into a signal which can be read by an observer or by an (today mostly electronic) instrument.<br />传感器是一个转换器，它测量一个物理量，并将其转换成一个信号，该信号可以被观察者或(今天主要是电子)仪器读取。</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><table><thead><tr><th>Type</th><th>特点</th></tr></thead><tbody><tr><td>Active sensors</td><td>generate electric current</td></tr><tr><td>Passive sensors</td><td>require additional other electrical energy</td></tr><tr><td>Contact sensor</td><td>requires physical contact</td></tr><tr><td>Non-contact sensor</td><td>no physical contact</td></tr></tbody></table><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/21.png" alt="Classification" /></p><h3 id="input-output"><a class="markdownIt-Anchor" href="#input-output"></a> Input &amp; Output</h3><ul><li>Input: stimulus or measurand (temperature, pressure, light intensity)</li><li>Output: electrical signal (voltage, current, frequency, phase)</li><li>Relation:<ul><li>Linear or nonlinear; single/multiple</li><li>inputs, single output;</li></ul></li></ul><h3 id="range-and-span"><a class="markdownIt-Anchor" href="#range-and-span"></a> Range and Span</h3><p>Example: a sensors is designed for: −30 °C to +80 °C<br />to output 2.5V to 1.2V<br />Range: −30°C and +80 °C<br />Span: 80− (−30)=110 °C<br />Input full scale = 110 °C<br />Output full scale = 2.5V-1.2V=1.3V</p><h3 id="error"><a class="markdownIt-Anchor" href="#error"></a> Error</h3><ul><li>Error Source</li></ul><table><thead><tr><th>name</th><th>名字</th></tr></thead><tbody><tr><td>materials used</td><td>材料</td></tr><tr><td>ageing</td><td>老化</td></tr><tr><td>operational errors</td><td>操作错误</td></tr><tr><td>calibration errors</td><td>校准错误</td></tr><tr><td>noise</td><td>噪音</td></tr></tbody></table><ul><li>Error 分类</li></ul><table><thead><tr><th>name</th><th>time dependent</th><th>cause</th></tr></thead><tbody><tr><td>Static errors</td><td>NO</td><td></td></tr><tr><td>Dynamic error</td><td>YES</td><td></td></tr><tr><td>System error</td><td></td><td>imperfect design of the measurement setup</td></tr><tr><td>Random errors</td><td></td><td>uncontrolled variables</td></tr></tbody></table><h3 id="一堆概念重点"><a class="markdownIt-Anchor" href="#一堆概念重点"></a> 一堆概念（重点）</h3><ul><li>Resolution(分辨力): the minimum increment in stimulus to which it can respond.<br />最小感知单元的大小</li><li>Accuracy(准确度): how closely the output  will match the true value.<br />感知信息的准确程度</li><li>Precision(精确度): how close the measured values are to each other.<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/22.png" alt="Accuracy &amp; Resolution" /><br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/23.png" alt="Accuracy &amp; Precision" /></li><li>Reliability(可靠性): reproducibility, indicates the ability of the device to perform its stated function.<br />也称为再现性:在不同时间测量时，传感器在相同条件下不能表示相同的值(即刺激或输入)。<br />对设备质量的一种统计测量，它表明设备在正常运行条件下，在规定的一段时间或若干个周期内不发生故障的情况下，执行规定功能的能力。</li><li>Sensitivity(灵敏度): represents the slope of the transfer function.<br />传感器的灵敏度定义为给定输入变化(通常是输入的单位变化)的输出变化。灵敏度表示传递函数的斜率。</li><li>Hysteresis(滞后程度): the deviation of the sensor’s output at any given point when approached from two different directions<br />滞后程度:当传感器从两个不同的方向接近任意给定点时，传感器输出的偏差</li><li>Linearity(线性度)： the deviation of the output from a best-fit straight line for a given range of the sensor<br />线性度: 在给定的传感器范围内，输出与最佳拟合直线的偏差<br />Response time(响应时间): delay time, indicates the time needed for the output to reach steady state for a step change in input.<br />表示输出达到稳态所需的时间。<br />Calibration(校准): the experimental determination of thetransfer function of a sensor.<br />校准:传感器传递函数的实验测定。<br />通常，当传递函数未知时，<br />当设备必须在低于制造商规定的公差下运行时。<br />例如，在0到100°C的温度范围内，使用容忍度为5%的热敏电阻来测量温度。</li></ul><h2 id="26-positioning-and-gps"><a class="markdownIt-Anchor" href="#26-positioning-and-gps"></a> 2.6 Positioning and GPS</h2><h3 id="定位基本原理重点"><a class="markdownIt-Anchor" href="#定位基本原理重点"></a> 定位基本原理（重点）</h3><p>Signals in the electromagnetic spectrum<br />Signal time transit from known points converted to distance<br />Distances/ directions to known points are solved for the unknown position</p><p>电磁波谱中的信号<br />信号时间从已知点转换为距离<br />由多个已知点的距离/方向由未知位置求出</p><ul><li>Cellular positioning- EOTD 细胞定位</li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Sensing_Technologies_of_IoT/24.png" alt="Cellular positioning" /></p><h3 id="gps"><a class="markdownIt-Anchor" href="#gps"></a> GPS</h3><ul><li>Global Positioning System</li><li>GPS provides:<br />① Location or positional fix<br />② Velocity<br />③ Direction of travel<br />④ Accurate time</li><li>GPS Basic Steps:</li></ul><table><thead><tr><th>Step</th><th>Name</th><th>Usage</th></tr></thead><tbody><tr><td>1</td><td>Positioning</td><td>知道SV的位置</td></tr><tr><td>2</td><td>Timing</td><td>知道准确时间</td></tr><tr><td>3</td><td>SV Ranging（卫星测距）</td><td>算出物体到SV的举例</td></tr><tr><td>4</td><td>Trilateration（三边测量）</td><td>找到物体在地球上的交叉点</td></tr><tr><td>5</td><td>Correction of errors</td><td>Correcting for  delays</td></tr></tbody></table><ul><li><p>Range from each satellite calculated<br />range = time delay * speed of light</p></li><li><p>Sources of Errors</p></li></ul><table><thead><tr><th>Name</th><th>名字</th></tr></thead><tbody><tr><td>atmosphere</td><td>大气</td></tr><tr><td>Satellite clock errors</td><td>卫星时钟误差</td></tr><tr><td>SV position errors</td><td>SV位置误差</td></tr><tr><td>Quality of GPS receiver</td><td>GPS接收机质量</td></tr><tr><td>Multi-path errors</td><td>多路径误差</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview of IoT</title>
      <link href="/Overview%20of%20IoT.html"/>
      <url>/Overview%20of%20IoT.html</url>
      
        <content type="html"><![CDATA[<h2 id="11-background-of-iot"><a class="markdownIt-Anchor" href="#11-background-of-iot"></a> 1.1 Background of IoT</h2><ul><li>Computing model involtion: 2010 IoT Pervasive（遍布的） &amp; senser Computing<br />计算模型involtion: 2010物联网无处不在&amp;传感器计算</li><li>The term Internet of Things was first used by Kevin Ashton in 1999<br />物联网一词最早由凯文·阿什顿在1999年使用</li><li>The very first definition of IoT derives from a “Things oriented” perspective;<br />物联网的第一个定义源于“面向事物”的视角;</li></ul><h2 id="12-concepts-and-characteristics-of-iot"><a class="markdownIt-Anchor" href="#12-concepts-and-characteristics-of-iot"></a> 1.2 Concepts and characteristics of IoT</h2><h3 id="some-concept-connect-with-iot"><a class="markdownIt-Anchor" href="#some-concept-connect-with-iot"></a> Some Concept connect with IoT</h3><h4 id="wsn-wireless-sensor-network无线传感网络"><a class="markdownIt-Anchor" href="#wsn-wireless-sensor-network无线传感网络"></a> WSN: wireless sensor network，无线传感网络</h4><p>WSN网络是由部署在监测区域内大量的廉价微型传感器节点组成，通过无线通信方式形成的一个自组织网络。<br />传感器网络将能扩展人们与现实世界进行远程交互的能力。无线传感器网络能够实时监测和采集网络分布区域内的各种监测对象的信息，以实现复杂的制定范围内目标监测和跟踪，具有快速展开、抗毁性强等特点。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/1.png" alt="WSN网络构成" /></p><h4 id="m2m-machine-to-machine-机器对机器"><a class="markdownIt-Anchor" href="#m2m-machine-to-machine-机器对机器"></a> M2M: Machine-To-Machine, 机器对机器</h4><p>M2M重点在于机器对机器的无线通信，存在以下三种方式：机器对机器，机器对移动电话（如用户远程监视），移动电话对机器（如用户远程控制）。<br />M2M的潜在市场不仅限于通信业。由于M2M是无线通信和信息技术的整合，它可用于双向通信，如远距离收集信息、设置参数和发送指令，因此M2M技术可有不同的应用方案，如安全监测、自动售货机、货物跟踪等</p><h4 id="cps-cyber-physical-systems信息物理系统"><a class="markdownIt-Anchor" href="#cps-cyber-physical-systems信息物理系统"></a> CPS: Cyber-Physical Systems，信息物理系统。</h4><ul><li>信息物理系统(cyber physical systems,简称CPS)作为计算进程和物理进程的统一体，是集成计算、通信与控制于一体的下一代智能系统。信息物理系统通过人机交互接口实现和物理进程的交互，使用网络化空间以远程的、可靠的、实时的、安全的、协作的方式操控一个物理实体。</li><li>信息物理系统包含了将来无处不在的环境感知、嵌入式计算、网络通信和网络控制等系统工程，使物理系统具有计算、通信、精确控制、远程协作和自治功能。它注重计算资源与物理资源的紧密结合与协调，主要用于一些智能系统上如设备互联，物联传感，智能家居，机器人，智能导航等。</li></ul><h3 id="defination-of-iot"><a class="markdownIt-Anchor" href="#defination-of-iot"></a> Defination of IoT</h3><ul><li>an integrated part of Future Internet and could be defined as a dynamic global network infrastructure with self configuring capabilities based on standard and interoperable communication protocols where physical and virtual ‘things’ have identities, physical attributes, and virtual personalities and use intelligent interfaces, and are seamlessly integrated into the information network.<br />未来互联网的一个集成部分,可能被定义为一个动态的全球网络基础设施具有自我配置功能基于标准和互操作通信协议在物理和虚拟的东西有身份,物理属性,和虚拟的个性和使用智能接口,并无缝地集成到信息网络。</li></ul><h3 id="characteristics-of-iot"><a class="markdownIt-Anchor" href="#characteristics-of-iot"></a> Characteristics of IoT</h3><ul><li>Functionalize ordinary objects 使普通对象功能化</li><li>Interconnect autonomic terminals 相互关联的自助终端</li></ul><h4 id="three-important-characteristics"><a class="markdownIt-Anchor" href="#three-important-characteristics"></a> Three important characteristics</h4><ul><li>instrumented (仪表化的)</li><li>interconnected</li><li>intelligent</li></ul><h2 id="13-architecture-of-iot-物联网架构"><a class="markdownIt-Anchor" href="#13-architecture-of-iot-物联网架构"></a> 1.3 Architecture of IoT 物联网架构</h2><h3 id="tcpip-layered-architectural-model"><a class="markdownIt-Anchor" href="#tcpip-layered-architectural-model"></a> TCP/IP Layered Architectural Model</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/2.png" alt="TCP/IP Layered Architectural Model" /><br />此处可以了解OSI七层进行系统学习</p><ul><li>Application 应用层<br />a user process cooperating with another process<br />on the same or a different host.<ul><li>TELNET: a protocol for remote terminal connections. 远程终端连接协议</li><li>FTP: File Transfer Protocol 文件传输协议</li><li>SMTP:  Simple Mail Transfer Protocol 邮件传输协议</li></ul></li><li>Transport 传输层<ul><li>TCP 有保障连接</li><li>UDP 无保障连接</li></ul></li><li>Internetwork 网络层<ul><li>IP Internet Protocol 互联网协议</li></ul></li><li>Network Interface（link layer） 网络接口，（数据）链路层<br />the interface to the actual network hardware 硬件接口协议层</li></ul><h3 id="four-layer-architecture-model-of-iot"><a class="markdownIt-Anchor" href="#four-layer-architecture-model-of-iot"></a> Four-layer architecture model of IoT</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/3.png" alt="Four-layer architecture model of IoT" /></p><ul><li>Object sensing layer 对象感知层<br />感知物理对象并获取数据</li><li>Data exchange layer 数据交换层<br />数据透明传输</li><li>Information integration layer 信息集成层<br />负责重组、清理和不确定信息的融合，将不确定信息整合到网络中或有用的部分。</li><li>Application service layer 应用服务层<br />为不同用户提供服务。</li></ul><h3 id="three-layer-architecture-model-of-iot"><a class="markdownIt-Anchor" href="#three-layer-architecture-model-of-iot"></a> Three-layer architecture model of IoT</h3><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/4.png" alt="Three-layer architecture model of IoT" /></p><ul><li>Application Layer 应用层</li><li>Network Layer 网络层</li><li>Sensor Layer 感知层</li></ul><h3 id="objectives-of-iot-物联网的目的"><a class="markdownIt-Anchor" href="#objectives-of-iot-物联网的目的"></a> Objectives of IoT 物联网的目的</h3><ul><li>More Extensive Interconnection 更广泛的互联<br />物联网扩展了信息设备之间的互连，电脑和手机，要互联互通，智能或非智能物理对象。</li><li>More Intensive Information Perception 更密集的信息感知<br />物联网扩展了传统单传感器感知局部的范例<br />环境自主向新范式转变，多传感器协作实现全球环境意识。</li><li>More Comprehensive Intelligent Service 更全面的智能服务<br />基于普通物理对象与网络的广泛互联<br />物联网可以提供对物理世界的深入感知，综合智能服务</li></ul><h2 id="key-technologies-of-iot-物联网关键技术"><a class="markdownIt-Anchor" href="#key-technologies-of-iot-物联网关键技术"></a> Key technologies of IoT 物联网关键技术</h2><h3 id="on-object-sensing-layer-对象感知层相关技术"><a class="markdownIt-Anchor" href="#on-object-sensing-layer-对象感知层相关技术"></a> on Object sensing layer 对象感知层相关技术</h3><ul><li><p>Barcode 条形码<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/5.png" alt="Barcode 条形码" /></p></li><li><p>Two-dimensional code or QR Code 二维码</p></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/6.png" alt="Two-dimensional code or QR Code" /></p><ul><li>IC card  IC卡<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/7.png" alt="IC card" /></li></ul><p>any pocket-sized card with embedded integrated circuits<br />智能卡可以提供身份识别，认证、数据存储和应用程序处理</p><ul><li><p>Radio Frequency Identification (RFID) 射频识别</p></li><li><p>Sensor 传感器<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/8.png" alt="Sensor" /></p></li><li><p>Sensor node（mote）传感器节点</p></li></ul><p>一个节点能够执行的无线传感器网络一些处理，收集感官信息和其他连接节点进行通信<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/9.png" alt="Sensor node" /></p><ul><li>GPS</li><li>Smart Device</li></ul><h3 id="on-data-exchanger-layer-数据交换层相关技术"><a class="markdownIt-Anchor" href="#on-data-exchanger-layer-数据交换层相关技术"></a> on Data exchanger layer 数据交换层相关技术</h3><ul><li>Internet 互联网</li><li>WiFi</li><li>WiMAX (Worldwide Interoperability for Microwave Access) 全球微波互操作性<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/10.png" alt="WiMAX" /></li></ul><p>IEEE802.16标准，又称WiMAX，或广带无线接入(Broadband Wireless Access，BWA)标准。它是一项无线城域网(WMAN)技术，是针对微波和毫米波频段提出的一种新的空中接口标准。它用于将802.11a无线接入热点连接到互联网，也可连结公司与家庭等环境至有线骨干线路。它可作为线缆和DSL的无线扩展技术，从而实现无线宽带接入。</p><ul><li>GSM (Global System for Mobile Communications) 全球移动通信系统</li></ul><p>由欧洲电信标准组织ETSI制订的一个数字移动通信标准。GSM标准的无处不在使得在移动电话运营商之间签署&quot;漫游协定&quot;后用户的国际漫游变得很平常。 GSM 较之它以前的标准最大的不同是它的信令和语音信道都是数字式的，因此GSM被看作是第二代 (2G)移动电话系统 。</p><ul><li><p>3G 第三代移动通信标准<br />3G是第三代移动通信技术，是指支持高速数据传输的蜂窝移动通讯技术。3G服务能够同时传送声音及数据信息。3G是将无线通信与国际互联网等多媒体通信结合的一代移动通信系统。</p></li><li><p>4G 第四代移动通信标准<br />将WLAN技术和3G通信技术进行了很好的结合，使图像的传输速度更快，让传输图像的质量和图像看起来更加清晰。在智能通信设备中应用4G通信技术让用户的上网速度更加迅速，速度可以高达100M。<br />商业部署移动WiMAX标准，并首次公映长期演进(LTE)标准。</p></li><li><p>Bluetooth 蓝牙<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/11.png" alt="bluetooth" /></p></li></ul><p>单模式面向高度集成、紧凑的设备，使用一个轻量级连接层(Link Layer)提供超低功耗的待机模式操作、简单设备恢复和可靠的点对多点数据传输，还能让联网传感器在蓝牙传输中安排好低功耗蓝牙流量的次序，同时还有高级节能和安全加密连接。</p><ul><li>ZigBee<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/12.png" alt="Zigbee" /></li></ul><p>一套使用小型、低功耗数字的通信协议的高级规范。</p><ul><li>6LoWPAN<br /><img src="https://blog-medias.cdn.bcebos.com/posts/IoT/Overview_of_IoT/13.png" alt="6LoWPAN" /></li></ul><p>6LoWPAN是低功率无线个人区域网络IPv6的首字母缩写。6lowpan组定义了封装和报头压缩机制，允许IPv6数据包通过基于IEEE 802.15.4的网络发送和接收。</p><h3 id="on-information-integration-layer-信息集成层相关技术"><a class="markdownIt-Anchor" href="#on-information-integration-layer-信息集成层相关技术"></a> on Information integration layer 信息集成层相关技术</h3><ul><li>Database 数据库<br />数据库是有组织的数据集合。数据通常以支持需要此信息的流程的方式组织起来，以对现实的相关方面建模。</li><li>Intelligent Information Processing 智能信息处理<br />智能信息处理是研究信息处理的基础理论。在这种情况下，人工智能（Artificial intelligence）技术可以成为有用的工具。智能系统可以应用于互联网搜索和数据挖掘（data-mining）、互联网衍生材料的解释（interpreting<br />Internet-derived material）、人机界面（ human Web interface）、远程状态监控（remote condition monitoringremote condition monitoring）等诸多领域。</li><li>Cloud computing 云计算<br />云计算是指通过网络(通常是Internet)将计算资源(硬件和软件)作为服务交付。</li><li>Network management 网络管理<br />Network management refers to the activities, methods, procedures, and tools that pertain to the operation, administration, maintenance, and provisioning of networked systems.<br />网络管理是指与网络系统的操作、管理、维护和供应相关的活动、方法、过程和工具。</li><li>Information security 信息安全<br />Information security means protecting information and information systems from unauthorized access, use,disclosure, disruption, modification, perusal, inspection, recording or destruction.<br />信息安全是指保护信息和信息系统不受未经授权的访问、使用、泄露、破坏、修改、浏览、检查、记录或销毁。</li></ul><h2 id="15-development-of-iot-in-academia-and-industry-物联网在学术界和工业界的发展"><a class="markdownIt-Anchor" href="#15-development-of-iot-in-academia-and-industry-物联网在学术界和工业界的发展"></a> 1.5 Development of IoT in academia and industry 物联网在学术界和工业界的发展</h2><ul><li>Planetary Skin 行星皮肤<br />相关领域:水资源管理、食品安全、能源、保护<br />生物多样性，燃料，气候变化等。</li><li>GreenOrbs<br />GreenOrbs实现了对森林的全年生态监测，采集各种感官数据，包括温度、湿度、光照、二氧化碳滴度等。</li><li>CitySee<br />无锡市城市二氧化碳传感器监测</li><li>Logistics Management 物流管理</li><li>Smart grid 智能电网</li><li>Intelligent video surveillance  智能视频监控技术</li><li>Intelligent traffic 智能交通</li><li>Intelligent medical 智能制药</li><li>Smart home 智能家居</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra Algorithm</title>
      <link href="/Dijkstra.html"/>
      <url>/Dijkstra.html</url>
      
        <content type="html"><![CDATA[<p>参考书籍：数据结构（C语言版）清华大学出版社</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>Dijkstra算法：Dijkstra提出了一个按路径长度递增的次序产生最短路径的算法。<br />Dijkstra算法解决的对象：单源点最短路径问题。</p><h2 id="算法实现思路"><a class="markdownIt-Anchor" href="#算法实现思路"></a> 算法实现思路</h2><ul><li>图中所有边存储在邻接表中，所有的顶点存储在一个结构体组中，通过其下标对顶点进行操作</li></ul><h3 id="结构体声明"><a class="markdownIt-Anchor" href="#结构体声明"></a> 结构体声明</h3><ol><li>边结构体的声明</li></ol><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>{</span>    <span class="hljs-keyword">int</span> adjvexNum; <span class="hljs-comment">//该弧所指向的顶点在图的定点结构体组中的下角标</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span>    <span class="hljs-keyword">int</span> weight;}ArcNode;</code></pre><ul><li>adjvexNum 为这条边的尾顶点的数组下标。</li><li>nextarc 为邻接表的下一条与顶点邻接的边。</li><li>weight 为边的权值。</li></ul><ol start="2"><li>顶点结构体的声明</li></ol><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexNode</span>{</span>    ArcNode *firstarc;    <span class="hljs-keyword">int</span> known;    <span class="hljs-keyword">int</span> dist;    <span class="hljs-keyword">int</span> path;    <span class="hljs-keyword">int</span> data;}VexNode,AdjList[MAX_VERTEX_NUM];</code></pre><ul><li>firstarc 指向其邻接表</li><li>known 表示该节点的最短路径是否已经明确。</li><li>dist 表示源点到该顶点的最短路径的长度（权值之和）</li><li>path 表示Dijkstra算法中某个顶点的在最短路径中的前序顶点，在算法过程中可能会发生改变。</li></ul><ol start="3"><li>图结构体声明</li></ol><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>    AdjList vertice;    <span class="hljs-keyword">int</span> vexnum,arcnum;  <span class="hljs-comment">// 图当前顶点数和边数</span>    GraphKind kind; <span class="hljs-comment">//图的种类类型</span>}MGraph;</code></pre><ul><li>vertice 用来存储一个图中顶点信息的数组</li></ul><h3 id="图的创建"><a class="markdownIt-Anchor" href="#图的创建"></a> 图的创建</h3><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> weight,MGraph &amp;G)</span></span>{    <span class="hljs-keyword">int</span> vex1,vex2;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++){ <span class="hljs-comment">//通过用户输入的数据匹配顶点对应的下标</span>        <span class="hljs-keyword">if</span>(a == G.vertice[i].data){            vex1 = i;        }        <span class="hljs-keyword">if</span>(b == G.vertice[i].data){            vex2 = i;        }    }    ArcNode *arcNode = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ArcNode)); <span class="hljs-comment">//初始化所有边</span>    arcNode-&gt;nextarc = <span class="hljs-literal">NULL</span>;    arcNode-&gt;adjvexNum = vex2;    arcNode-&gt;weight = weight;    <span class="hljs-keyword">if</span>(G.vertice[vex1].firstarc == <span class="hljs-literal">NULL</span>){    <span class="hljs-comment">//将边加入到邻接表</span>        G.vertice[vex1].firstarc = arcNode;    }    <span class="hljs-keyword">else</span>{        ArcNode *t = <span class="hljs-literal">NULL</span>;        ArcNode *pre = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">for</span>(t = G.vertice[vex1].firstarc;t != <span class="hljs-literal">NULL</span>;t = t-&gt;nextarc){            pre = t;        }        pre-&gt;nextarc = arcNode;    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph &amp;G)</span></span>{    <span class="hljs-comment">//scanf("%d %d",&amp;G.vexnum,&amp;G.arcnum);</span>    G.vexnum = <span class="hljs-number">7</span>;    G.arcnum = <span class="hljs-number">12</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) {  <span class="hljs-comment">//初始化所有顶点</span>        G.vertice[i].firstarc = <span class="hljs-literal">NULL</span>;        G.vertice[i].known = <span class="hljs-number">0</span>;        G.vertice[i].dist = INT_MAX;        G.vertice[i].path = <span class="hljs-number">-1</span>;    }    G.vertice[<span class="hljs-number">0</span>].data = <span class="hljs-number">1</span>;    G.vertice[<span class="hljs-number">1</span>].data = <span class="hljs-number">2</span>;    G.vertice[<span class="hljs-number">2</span>].data = <span class="hljs-number">3</span>;    G.vertice[<span class="hljs-number">3</span>].data = <span class="hljs-number">4</span>;    G.vertice[<span class="hljs-number">4</span>].data = <span class="hljs-number">5</span>;    G.vertice[<span class="hljs-number">5</span>].data = <span class="hljs-number">6</span>;    G.vertice[<span class="hljs-number">6</span>].data = <span class="hljs-number">7</span>;<span class="hljs-comment">//for(int k = 0; k &lt; G.arcnum; k++){</span><span class="hljs-comment">// int vex1,vex2,weight;  //输入一条边的起点和终点以及这条边的权值</span><span class="hljs-comment">//  scanf("%d %d",&amp;vex1,&amp;vex2);</span><span class="hljs-comment">//}</span>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">12</span>]={            <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>    };    <span class="hljs-keyword">int</span> b[<span class="hljs-number">12</span>]={            <span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>    };    <span class="hljs-keyword">int</span> weight[<span class="hljs-number">12</span>]={            <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>    };    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.arcnum; i++)    addEdge(a[i],b[i],weight[i],G);}</code></pre><ul><li>初始化所有顶点的known值为0</li><li>初始化所有顶点的dist值为INT_MAX，为了满足Dijkstra算法寻找最短路径的操作，所以初值要设定为最大值。</li><li>所有顶点的前序节点path都默认为 -1，方便在所有节点都得到前置节点时通过-1找到初始节点并停止寻找path。</li></ul><h3 id="dijkstra-算法"><a class="markdownIt-Anchor" href="#dijkstra-算法"></a> Dijkstra 算法</h3><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(MGraph G)</span></span>{    G.vertice[<span class="hljs-number">0</span>].known = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化源节点</span>    G.vertice[<span class="hljs-number">0</span>].dist = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (ArcNode *t = G.vertice[<span class="hljs-number">0</span>].firstarc; t; t = t-&gt;nextarc) {        G.vertice[t-&gt;adjvexNum].dist = t-&gt;weight;        G.vertice[t-&gt;adjvexNum].path = <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">int</span> k; <span class="hljs-comment">// 权值最小路径尾顶点下标</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; G.vexnum; i++){        <span class="hljs-keyword">int</span> min = INT_MAX;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G.vexnum; j++)        {            <span class="hljs-keyword">if</span> (G.vertice[j].known == <span class="hljs-number">0</span> &amp;&amp; G.vertice[j].dist &lt; min)            {                min = G.vertice[j].dist;                k = j;            }        }        G.vertice[k].known = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span>        <span class="hljs-keyword">for</span> (ArcNode *t = G.vertice[k].firstarc; t; t = t-&gt;nextarc) {            <span class="hljs-keyword">if</span> (!G.vertice[t-&gt;adjvexNum].known) {                <span class="hljs-keyword">if</span>(G.vertice[k].dist + t-&gt;weight &lt; G.vertice[t-&gt;adjvexNum].dist) {                    G.vertice[t-&gt;adjvexNum].dist = G.vertice[k].dist + t-&gt;weight;                    G.vertice[t-&gt;adjvexNum].path = k;                }            }        }    }    <span class="hljs-keyword">int</span> target = <span class="hljs-number">6</span>;  <span class="hljs-comment">// 用户输入的终点</span>    <span class="hljs-keyword">int</span> dataset[<span class="hljs-number">100</span>];  <span class="hljs-comment">// 用于整理path数据正向输出路径</span>    <span class="hljs-keyword">int</span> dataNum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++){        <span class="hljs-keyword">if</span>(G.vertice[i].data == target){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k != <span class="hljs-number">-1</span>; k = G.vertice[k].path){ <span class="hljs-comment">// 正序输出最小路径</span>                dataset[dataNum] = G.vertice[k].data;                dataNum++;            }            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = dataNum<span class="hljs-number">-1</span>;l &gt; <span class="hljs-number">0</span>; l--){                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d,"</span>,dataset[l]);            }            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,dataset[<span class="hljs-number">0</span>]);        }    }}</code></pre><ol><li>源点数据初始化</li></ol><pre class="highlight"><code class="C">G.vertice[<span class="hljs-number">0</span>].known = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化源节点</span>G.vertice[<span class="hljs-number">0</span>].dist = <span class="hljs-number">0</span>;</code></pre><ol start="2"><li>为源点邻接的顶点设置dist值和path值</li></ol><pre class="highlight"><code class="C"><span class="hljs-keyword">for</span> (ArcNode *t = G.vertice[<span class="hljs-number">0</span>].firstarc; t; t = t-&gt;nextarc) {        G.vertice[t-&gt;adjvexNum].dist = t-&gt;weight;        G.vertice[t-&gt;adjvexNum].path = <span class="hljs-number">0</span>;    }</code></pre><ol start="3"><li>开始循环判断所有除源点以外其他顶点的dist值和path值</li></ol><ul><li>循环进行下述两步操作</li></ul><pre class="highlight"><code class="C"><span class="hljs-keyword">int</span> min = INT_MAX;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G.vexnum; j++)        {            <span class="hljs-keyword">if</span> (G.vertice[j].known == <span class="hljs-number">0</span> &amp;&amp; G.vertice[j].dist &lt; min)            {                min = G.vertice[j].dist;                k = j;            }        }</code></pre><ul><li>找到与该顶点 j 相邻最近的点 k（对应的边权值最小）</li></ul><pre class="highlight"><code class="C">G.vertice[k].known = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span>        <span class="hljs-keyword">for</span> (ArcNode *t = G.vertice[k].firstarc; t; t = t-&gt;nextarc) {            <span class="hljs-keyword">if</span> (!G.vertice[t-&gt;adjvexNum].known) {                <span class="hljs-keyword">if</span>(G.vertice[k].dist + t-&gt;weight &lt; G.vertice[t-&gt;adjvexNum].dist) {                    G.vertice[t-&gt;adjvexNum].dist = G.vertice[k].dist + t-&gt;weight;                    G.vertice[t-&gt;adjvexNum].path = k;                }            }        }</code></pre><ul><li>与所有与点k相邻的点比较其dist值</li><li>k点的dist值与k点到邻点边的权值之和与其相邻的点的dist值比较，若前者小，则更新路径值dist和前序顶点path。</li></ul><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><ul><li>若该节点没有被赋值，则dist值为正无穷，判断结果一定失败。</li><li>若该节点有过值通过k点的最短路径长度和与其相邻的权值足以与之前的dist值对应的情况进行比较哪个是更短的路径，对每个顶点入度的情况都遍历检查了一遍，达到效率较优的情况下检查全图得到源点到目标顶点最短路径的目的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="/Topological%20Sort.html"/>
      <url>/Topological%20Sort.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>定义：由某个集合上的一个偏序得到该集合上的全序的过程。</p><h3 id="离散数学相关概念"><a class="markdownIt-Anchor" href="#离散数学相关概念"></a> 离散数学相关概念</h3><ul><li><p>偏序：若集合X上的关系R是自反的、反对称的和传递的、则称R是集合X上的偏序关系。</p></li><li><p>全序：设R是集合X上的偏序。如果对每个x，y∈X必有xRy或yRx，则称R是集合X上的全序关系。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/Topological_Sort/1.png" alt="偏序与全序的有向图" /><br />由上图所示在（b）图表示全序，而（a）的有向图上人为地加上一个表示V<sub>2</sub>&lt;V<sub>3</sub>的弧（表示V<sub>2</sub>领先于V<sub>3</sub>）则（a）表示的亦为全序，这个全序称为<strong>拓补有序</strong>，由偏序定义得到拓补有序的操作便是拓补排序。</p></li><li><p>表示偏序的有向图可以用来表示流程图。图中的每一条边表示两个子工程之间的次序关系。</p></li></ul><h3 id="aov网activity-on-vertex-network"><a class="markdownIt-Anchor" href="#aov网activity-on-vertex-network"></a> AOV网（Activity on vertex Network）</h3><p>定义：用顶点表示活动，用弧表示活动间的优先关系的有向图称为定点表示活动的网。顾名思义。</p><ul><li><p>在网中，若从顶点i到另一顶点j之间有一条有向路径，则称i为j的前驱，j为i的后继。</p></li><li><p>在AOV网中不应该出现有向环，因为存在环意味着某项活动会以自己为先决条件，这是不对的。因此要对给定的AOV网进行判断是否有环。检测方法就是对AOV网进行拓补排序，若所有顶点都在拓补有序序列中，则AOV网中必没有环。</p></li></ul><h2 id="拓补排序的实现"><a class="markdownIt-Anchor" href="#拓补排序的实现"></a> 拓补排序的实现</h2><ol><li>在有向图中选择没有前驱的点的顶点并将其输出。</li><li>从图中删除该顶点和所有以它为尾的弧。<br />重复上面的两部，直到所有顶点均已经输出。</li></ol><ul><li>采用邻接表作有向图的存储结构。</li><li>声明存放顶点入度的数组 Indegree，入度为零的顶点即为没有前驱的顶点。</li><li>删除顶点以及以它为尾的弧的操作，则可更换为弧头顶点入度减一的操作。</li><li>为了避免重复检测入度为零的情况。另设一个线性表（栈或队列，根据题内特殊要求而定，就拓补排序定义而言无差别）暂存所有在删除弧操作后产生的新的入度为零的点。</li></ul><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><p>对于有n个顶点和e条弧的有向图而言总的时间复杂度为O（n+e）</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 40</span><span class="hljs-comment">//图的邻接矩阵表示方式</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {DG,DN,UDG,UDN} GraphKind;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>{</span>    <span class="hljs-keyword">int</span> adjvexNum; <span class="hljs-comment">//该弧所指向的顶点在图的定点结构体组中的下角标</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span>}ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexNode</span>{</span>    ArcNode *firstarc;    <span class="hljs-keyword">char</span> data;}VexNode,AdjList[MAX_VERTEX_NUM];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>    AdjList vertice;    <span class="hljs-keyword">int</span> vexnum,arcnum;  <span class="hljs-comment">// 图当前顶点数和边数</span>    GraphKind kind; <span class="hljs-comment">//图的种类类型</span>}MGraph;<span class="hljs-keyword">int</span> Visited[MAX_VERTEX_NUM] = {<span class="hljs-number">0</span>};<span class="hljs-keyword">int</span> Indegree[MAX_VERTEX_NUM] = {<span class="hljs-number">0</span>};<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a,<span class="hljs-keyword">char</span> b,MGraph &amp;G)</span></span>{<span class="hljs-keyword">int</span> vex1,vex2;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++){<span class="hljs-keyword">if</span>(a == G.vertice[i].data){vex1 = i;}<span class="hljs-keyword">if</span>(b == G.vertice[i].data){vex2 = i;}}Indegree[vex2]++;        ArcNode *arcNode = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ArcNode)); <span class="hljs-comment">//初始化所有边</span>        arcNode-&gt;nextarc = <span class="hljs-literal">NULL</span>;        arcNode-&gt;adjvexNum = vex2;        <span class="hljs-keyword">if</span>(G.vertice[vex1].firstarc == <span class="hljs-literal">NULL</span>){    <span class="hljs-comment">//将边加入到邻接表</span>            G.vertice[vex1].firstarc = arcNode;        }        <span class="hljs-keyword">else</span>{            ArcNode *t = <span class="hljs-literal">NULL</span>;            ArcNode *pre = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">for</span>(t = G.vertice[vex1].firstarc;t != <span class="hljs-literal">NULL</span>;t = t-&gt;nextarc){                pre = t;            }            pre-&gt;nextarc = arcNode;        }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph &amp;G)</span></span>{    <span class="hljs-comment">//scanf("%d %d",&amp;G.vexnum,&amp;G.arcnum);</span>    G.vexnum = <span class="hljs-number">11</span>;    G.arcnum = <span class="hljs-number">21</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) {  <span class="hljs-comment">//初始化所有顶点</span>        G.vertice[i].firstarc = <span class="hljs-literal">NULL</span>;    }    G.vertice[<span class="hljs-number">0</span>].data = <span class="hljs-string">'S'</span>;    G.vertice[<span class="hljs-number">1</span>].data = <span class="hljs-string">'A'</span>;    G.vertice[<span class="hljs-number">2</span>].data = <span class="hljs-string">'B'</span>;    G.vertice[<span class="hljs-number">3</span>].data = <span class="hljs-string">'C'</span>;    G.vertice[<span class="hljs-number">4</span>].data = <span class="hljs-string">'D'</span>;    G.vertice[<span class="hljs-number">5</span>].data = <span class="hljs-string">'E'</span>;    G.vertice[<span class="hljs-number">6</span>].data = <span class="hljs-string">'F'</span>;    G.vertice[<span class="hljs-number">7</span>].data = <span class="hljs-string">'G'</span>;    G.vertice[<span class="hljs-number">8</span>].data = <span class="hljs-string">'H'</span>;    G.vertice[<span class="hljs-number">9</span>].data = <span class="hljs-string">'I'</span>;    G.vertice[<span class="hljs-number">10</span>].data = <span class="hljs-string">'T'</span>;    <span class="hljs-comment">//for(int k = 0; k &lt; G.arcnum; k++){</span>    <span class="hljs-comment">// int vex1,vex2,weight;  //输入一条边的起点和终点以及这条边的权值</span>    <span class="hljs-comment">//  scanf("%d %d",&amp;vex1,&amp;vex2);</span>    <span class="hljs-comment">//}</span>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">21</span>]={    <span class="hljs-string">'S'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'A'</span>,<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'I'</span>,<span class="hljs-string">'I'</span>    };    <span class="hljs-keyword">char</span> b[<span class="hljs-number">21</span>]={   <span class="hljs-string">'A'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'A'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'I'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'I'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'T'</span>    };    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.arcnum; i++){    Insert(a[i],b[i],G);    }}<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span><span class="hljs-keyword">int</span> data;}QNodes[<span class="hljs-number">100</span>];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span><span class="hljs-keyword">int</span> head;<span class="hljs-keyword">int</span> tail;QNodes qNodes;}Queue;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(MGraph G)</span></span>{<span class="hljs-keyword">int</span> TopNum[MAX_VERTEX_NUM] = {<span class="hljs-number">0</span>};Queue <span class="hljs-built_in">queue</span>;<span class="hljs-built_in">queue</span>.tail = <span class="hljs-number">0</span>;<span class="hljs-built_in">queue</span>.head = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum;i++) {        <span class="hljs-keyword">if</span>(Indegree[i] == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.tail].data = i;        <span class="hljs-built_in">queue</span>.tail++;        }}        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">queue</span>.tail != <span class="hljs-built_in">queue</span>.head){        <span class="hljs-keyword">int</span> p = <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.head].data;        <span class="hljs-built_in">queue</span>.head++;        TopNum[counter] = p;        counter++;        <span class="hljs-keyword">for</span>(ArcNode *t = G.vertice[p].firstarc;t;t = t-&gt;nextarc){        Indegree[t-&gt;adjvexNum]--;        <span class="hljs-keyword">if</span>(!Indegree[t-&gt;adjvexNum]){        <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.tail].data = t-&gt;adjvexNum;                <span class="hljs-built_in">queue</span>.tail++;        }        }        }    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; counter; i++){      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c,"</span>,G.vertice[TopNum[i]].data);    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    MGraph graph;    CreateGraph(graph);    TopologicalSort(graph);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph</title>
      <link href="/Graph.html"/>
      <url>/Graph.html</url>
      
        <content type="html"><![CDATA[<p>参考博文：<a href="https://www.cnblogs.com/xiaobingqianrui/p/8902111.html" target="_blank" rel="noopener">数据结构之图的基本概念</a><br />参考书籍：数据结构（C语言版）清华大学出版社</p><h1 id="图的基本概念"><a class="markdownIt-Anchor" href="#图的基本概念"></a> 图的基本概念</h1><h2 id="图的定义"><a class="markdownIt-Anchor" href="#图的定义"></a> 图的定义</h2><ul><li>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中<strong>顶点的集合</strong>，E是图G中<strong>边的集合</strong>。</li><li>图相比线性表和树形结构<ul><li>在线性表中，数据元素之间仅有线性关系，每个元素只有一个直接前驱和一个直接后继。</li><li>在树型结构中，数据元素之间有着明显的层关系，并且每个元素只有一个前驱，可能有多个后继。</li><li>而在图形结构中，节点之间的关系可以是任意的，图中任意两个元素都有可能有关。</li></ul></li><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为<strong>顶点（Vertex）</strong>。</li><li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点（有穷非空性）。</li><li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示（边集可以为空），这里要强调对边集概念的重视。</li></ul><h2 id="图的分类"><a class="markdownIt-Anchor" href="#图的分类"></a> 图的分类</h2><ol><li>无向图<br />如果图中任何两个顶点之间都是无向边，则称为该图为无向图(Undirected graphs)。</li><li>有向图<br />如果图中任意两个顶点之间的边都是有向边（简而言之就是有方向的边），则称该图为有向图（Directed graphs）。</li><li>完全图<br />①无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。（含有n个顶点的无向完全图有(n×(n-1))/2条边）<br />②有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。（含有n个顶点的有向完全图有n×(n-1)条边）</li><li>稀疏图/稠密图<br />有很少的边或弧的图成为稀疏图，反之接近完全图的图则称为稠密图。</li></ol><h2 id="图相关的概念"><a class="markdownIt-Anchor" href="#图相关的概念"></a> 图相关的概念</h2><ol><li>顶点的度<br />顶点Vi的度（Degree）是指在图中与Vi相关联的边的条数。对于有向图来说，有入度（In-degree）和出度（Out-degree）之分，有向图顶点的度等于该顶点的入度和出度之和。</li><li>邻接（Adjacent）</li></ol><ul><li>若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接。</li><li>若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3</li><li>无向图中的边使用小括号“()”表示，而有向图中的边使用尖括号“&lt;&gt;”表示。</li></ul><ol start="3"><li>路径（Path）</li></ol><ul><li>在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径。</li><li>序列中顶点不重复出现的路径称为简单路径。</li></ul><ol start="4"><li>回路/环（Cycle/Loop）<br />在路径概念的基础上，第一个顶点和最后一个顶点相同的路径称为一个回路或环。</li><li>权（Weight）</li></ol><ul><li>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。</li><li>权的数值储存在邻接表的弧节点内。</li></ul><ol start="6"><li>有向网/无向网<br />即为有权值属性的有向图/无向图</li></ol><h2 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h2><h3 id="数组表示法邻接矩阵表示法"><a class="markdownIt-Anchor" href="#数组表示法邻接矩阵表示法"></a> 数组表示法（邻接矩阵表示法）</h3><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。<strong>一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</strong></p><ol><li>结构体声明：</li></ol><pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20</span><span class="hljs-comment">//图的邻接矩阵表示方式</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {DG,DN,UDG,UDN} GraphKind;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcCell</span>{</span>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">//该项对于无权图，用0或1来表示连接与否</span>}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>    <span class="hljs-keyword">int</span> vex[MAX_VERTEX_NUM]; <span class="hljs-comment">//构造顶点向量</span>    AdjMatrix arcs; <span class="hljs-comment">//图的邻接矩阵</span>    <span class="hljs-keyword">int</span> vexnum,arcnum;  <span class="hljs-comment">// 图当前顶点数和边数</span>    GraphKind kind; <span class="hljs-comment">//图的种类类型</span>}MGraph;</code></pre><ul><li>只声明边结构体和图结构体，无需声明顶点结构体。</li><li>邻接矩阵表示的是一个n个顶点与n个顶点之间n<sup>2</sup>个边情况的矩阵</li><li>weight值<br />在有权图中有连接代表权值，两顶点间无连接为0，有连接表示为权值<br />在无权图中该位置存储边的关系，默认无连接为0，有连接为1</li></ul><ol start="2"><li>图的建立</li></ol><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph &amp;G)</span></span>{    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;G.vexnum,&amp;G.arcnum);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;G.vex[i]); <span class="hljs-comment">//构造顶点向量</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G.vexnum; j++) {            G.arcs[i][j].weight = <span class="hljs-number">0</span>;  <span class="hljs-comment">//初始化邻接矩阵</span>        }    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++){        <span class="hljs-keyword">int</span> vex1,vex2,weight;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>,&amp;vex1,&amp;vex2,&amp;weight);        <span class="hljs-keyword">int</span> v1,v2;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++){ <span class="hljs-comment">//找到顶点在图中的下标</span>            <span class="hljs-keyword">if</span>(G.vex[i] == vex1){                v1 = i;            }            <span class="hljs-keyword">if</span>(G.vex[i] == vex2){                v2 = i;            }        }        G.arcs[v1][v2].weight = weight;        G.arcs[v2][v1].weight = weight; <span class="hljs-comment">//有向图省略此部，</span>    }}</code></pre><h3 id="邻接表adjacency-list"><a class="markdownIt-Anchor" href="#邻接表adjacency-list"></a> 邻接表（Adjacency List）</h3><p>邻接表是一种图的链式存储结构。图中存储了每个表的头节点，也就是所有顶点信息，我们可以通过顶点访问到与其邻接的每条边的信息。</p><ol><li>结构体声明</li></ol><pre class="highlight"><code class="C"><span class="hljs-comment">//图的邻接矩阵表示方式</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {DG,DN,UDG,UDN} GraphKind;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>{</span>    <span class="hljs-keyword">int</span> adjvexNum; <span class="hljs-comment">//该弧所指向的顶点在图的定点结构体组中的下角标</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">//该项对于无权图，可删除此项</span>}ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexNode</span>{</span>    ArcNode *firstarc;    <span class="hljs-keyword">int</span> data;}VexNode,AdjList[MAX_VERTEX_NUM];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>    AdjList vertice;    <span class="hljs-keyword">int</span> vexnum,arcnum;  <span class="hljs-comment">// 图当前顶点数和边数</span>    GraphKind kind; <span class="hljs-comment">//图的种类类型</span>}MGraph;<span class="hljs-keyword">int</span> Visited[MAX_VERTEX_NUM] = {<span class="hljs-number">0</span>};</code></pre><ol start="2"><li>图的建立</li></ol><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(MGraph &amp;G)</span></span>{    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;G.vexnum,&amp;G.arcnum);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) {  <span class="hljs-comment">//初始化所有顶点</span>        G.vertice[i].firstarc = <span class="hljs-literal">NULL</span>;        G.vertice[i].data = i;    }    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++){        <span class="hljs-keyword">int</span> vex1,vex2,weight;  <span class="hljs-comment">//输入一条边的起点和终点以及这条边的权值</span>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>,&amp;vex1,&amp;vex2,&amp;weight);        ArcNode *arcNode = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ArcNode)); <span class="hljs-comment">//初始化所有边</span>        arcNode-&gt;nextarc = <span class="hljs-literal">NULL</span>;        arcNode-&gt;adjvexNum = vex2;        arcNode-&gt;weight = weight;        <span class="hljs-keyword">if</span>(G.vertice[vex1].firstarc == <span class="hljs-literal">NULL</span>){    <span class="hljs-comment">//将边加入到邻接表</span>            G.vertice[vex1].firstarc = arcNode;        }        <span class="hljs-keyword">else</span>{            ArcNode *t = <span class="hljs-literal">NULL</span>;            ArcNode *pre = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">for</span>(t = G.vertice[vex1].firstarc;t != <span class="hljs-literal">NULL</span>;t = t-&gt;nextarc){                pre = t;            }            pre-&gt;nextarc = arcNode;        }    }}</code></pre><h2 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h2><h3 id="深搜"><a class="markdownIt-Anchor" href="#深搜"></a> 深搜</h3><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(MGraph G,<span class="hljs-keyword">int</span> V)</span></span>{    Visited[V] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,G.vertice[V].data);    ArcNode *t = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span>(t = G.vertice[V].firstarc;t;t = t-&gt;nextarc){    <span class="hljs-keyword">if</span>(Visited[t-&gt;adjvexNum] == <span class="hljs-number">0</span>)  DFS(G,t-&gt;adjvexNum);    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    MGraph graph;    CreateGraph(graph);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.vexnum;i++) {        <span class="hljs-keyword">if</span>(Visited[i] == <span class="hljs-number">0</span>) DFS(graph,i);    }}</code></pre><h3 id="广搜"><a class="markdownIt-Anchor" href="#广搜"></a> 广搜</h3><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span><span class="hljs-keyword">int</span> data;}QNodes[<span class="hljs-number">100</span>];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span><span class="hljs-keyword">int</span> tail;QNodes qNodes;}Queue;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(MGraph G,<span class="hljs-keyword">int</span> V)</span></span>{    Queue <span class="hljs-built_in">queue</span>;    <span class="hljs-built_in">queue</span>.tail = <span class="hljs-number">0</span>;    <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.tail].data = V;    <span class="hljs-built_in">queue</span>.tail++;    Visited[V] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,G.vertice[V].data);   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">queue</span>.tail){      <span class="hljs-keyword">int</span> p = <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.tail<span class="hljs-number">-1</span>].data; <span class="hljs-comment">//取队列元素</span>      <span class="hljs-built_in">queue</span>.tail--;     <span class="hljs-comment">//弹出队首元素</span>      <span class="hljs-keyword">for</span>(ArcNode* t = G.vertice[p].firstarc;t;t = t-&gt;nextarc){      <span class="hljs-keyword">if</span>(Visited[t-&gt;adjvexNum] == <span class="hljs-number">0</span>){      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,G.vertice[t-&gt;adjvexNum].data);      Visited[t-&gt;adjvexNum] = <span class="hljs-number">1</span>;      <span class="hljs-built_in">queue</span>.tail++;      <span class="hljs-built_in">queue</span>.qNodes[<span class="hljs-built_in">queue</span>.tail].data = t-&gt;adjvexNum;      }      }   }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    MGraph graph;    CreateGraph(graph);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.vexnum;i++) {        <span class="hljs-keyword">if</span>(Visited[i] == <span class="hljs-number">0</span>) BFS(graph,i);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Programs</title>
      <link href="/CSS%20Programs.html"/>
      <url>/CSS%20Programs.html</url>
      
        <content type="html"><![CDATA[<h2 id="网页效果目前支持chromeie等浏览器移动端支持safari不支持安卓大部分浏览器"><a class="markdownIt-Anchor" href="#网页效果目前支持chromeie等浏览器移动端支持safari不支持安卓大部分浏览器"></a> 网页效果目前支持Chrome，IE等浏览器，移动端支持Safari,不支持安卓大部分浏览器</h2><ul><li><a href="/projects/Layered-Image-Hover-Effects">Layered Image Hover Effects</a></li><li><a href="/projects/Price-Card-UI-Design">Price Card UI Design</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transport layer</title>
      <link href="/Transport%20layer.html"/>
      <url>/Transport%20layer.html</url>
      
        <content type="html"><![CDATA[<h2 id="传输层概述"><a class="markdownIt-Anchor" href="#传输层概述"></a> 传输层概述</h2><ul><li>应用层协议的消息传输需要可靠性，而仅靠网络层IP不可靠，数据可能会出错、丢失或乱序等异常情况。</li><li>传输层实现端到端的可靠通信</li><li>传输层负责将向目标IP地址发送的消息通过传输层协议中的端口号传入特定进程。</li><li>传输层提供了面向连接的机制：可靠传输、流量控制、拥塞控制。</li><li>传输层不提供时延保障和带宽保障。</li></ul><h3 id="进程之间的通信"><a class="markdownIt-Anchor" href="#进程之间的通信"></a> 进程之间的通信</h3><ul><li>传输层属于面向通信部分的最高层，但也是用户功能中的最底层。</li><li>严格地讲，两台主机进行通信就是两个应用进程在交换数据。所以从传输层的角度看，通信真正的端点并不是IP地址所定位的主机，而是主机中的进程。</li><li>网络层和传输层有着明显区别。网络层为主机之间提供逻辑通信，而运输层为应用之间提供通信。</li></ul><h4 id="传输层重要功能复用和分用"><a class="markdownIt-Anchor" href="#传输层重要功能复用和分用"></a> 传输层重要功能：复用和分用</h4><ol><li><p>复用是指在发送方不同的应用进程中都可以使用同一个传输层协议。<br />源端传输层会在应用层数据前加上源端口号和目标端口号。<br />进程表示：16位端口号</p></li><li><p>分用是指在接收方的传输层剥去报文首部后能够把这些数据正确地交付目标应用进程。</p></li></ol><h4 id="端口号的规定"><a class="markdownIt-Anchor" href="#端口号的规定"></a> 端口号的规定</h4><ol><li>熟知端口（常用端口，Well-known port）<ul><li>服务器进程使用</li><li>开放并且端口号固定</li><li>Web服务器（HTTP）端口一般为80，<br />Telnet服务器端口号一般为23，<br />FTP端口号一般为21，<br />DNS端口号一般为53。</li><li>值一般小于1024</li></ul></li><li>短暂端口<ul><li>用户进程使用</li><li>由操作系统分配，值不固定</li><li>值大于5000</li></ul></li></ol><h2 id="无连接传输协议udp"><a class="markdownIt-Anchor" href="#无连接传输协议udp"></a> 无连接传输协议：UDP</h2><h3 id="udp的概念"><a class="markdownIt-Anchor" href="#udp的概念"></a> UDP的概念</h3><p>又名用户数据报协议，一种简单高效的传输层协议。</p><h3 id="udp的特点"><a class="markdownIt-Anchor" href="#udp的特点"></a> UDP的特点</h3><ol><li><p>UDP是无连接的。<br />即发送数据前不需要建立连接，减少了开销和发送数据的时延。</p></li><li><p>UDP使用最大努力交付。<br />牺牲可靠性。</p></li><li><p>UDP是面向报文的。</p><ul><li>UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。</li><li>UDP对交下来的报文既不合并，也不拆分，而是保留这些报文的边界。（原样发送）</li><li>若报文太长UDP把报文传给IP层后，IP层可能要进行分片，这会降低IP层的效率。</li><li>反之，若报文长度太短，UDP把报文交给IP层会导致首部相对长度太大，也降低了IP层的效率。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/Computer_Network/Transport_layer/1.png" alt="UDP是面向报文的" /></li></ul></li><li><p>UDP没有拥塞控制<br />因此网络出现的拥塞不会使源主机的发送速率降低，对某些实时应用很重要，他们要求源主机以恒定的速率发送数据，并且允许丢失一些数据，但却不允许有较大的时延。UDP刚好能满足这个需求。</p></li><li><p>UDP支持一对一、一对多、多对一、多对多的交互通信。</p></li><li><p>UDP的首部开销小<br />UDP的首部只有8个字节，比TCP的20个字节的首部要短很多。</p></li></ol><h3 id="udp的应用"><a class="markdownIt-Anchor" href="#udp的应用"></a> UDP的应用</h3><ol><li>虽然实时应用需要没有拥塞控制的UDP，但当很多源主机都同时向网络发送高频率的实时视频流时，网络就有可能发生阻塞，结果就是大家都无法正常接收。因此没有拥塞控制的UDP有可能引起网络产生的严重拥塞问题。</li><li>有一些使用UDP的实时应用，需要对UDP的不可靠的传输进行适当的改进，以减少数据的丢失。可以在不影响应用层的实时性的前提下，增加一些提高可靠性的措施，如采用向前纠错或重传已丢失的报文。</li></ol><ul><li>前向纠错：前向纠错是一种差错控制方式，它是指信号在被送入传输信道之前预先按一定的算法进行编码处理，加入带有信号本身特征的冗码，在接收端按照相应算法对接收到的信号进行解码，从而找出在传输过程中产生的错误码并将其纠正的技术。</li></ul><h3 id="udp的首部格式"><a class="markdownIt-Anchor" href="#udp的首部格式"></a> UDP的首部格式</h3><p>用户数据报有两个字段，数据字段和首部字段，首部字段只有八个字节。由四个字段组成，每个字段都是两个字节，各字段意义：</p><ol><li>源端口号：在需要对方回信时选用，不需要可全用0。</li><li>目的端口号：在终点时交付报文必须需要。</li><li>长度：UDP数据报的长度，其最小值是8。</li><li>检验和：检验UDP在传输过程是否有错，有错就丢弃。</li></ol><p><img src="https://blog-medias.cdn.bcebos.com/posts/Computer_Network/Transport_layer/2.png" alt="UDP用户数据报的首部部和伪首部" /></p><h3 id="udp的伪首部"><a class="markdownIt-Anchor" href="#udp的伪首部"></a> UDP的伪首部</h3><p>UDP用户数据报的检验方法有一些特殊。在计算校验和时需要在数据报前加上12个字节的伪首部。在计算校验和时临时添加在UDP数据报前面，伪首部既不向下传送也不向上提交，仅仅是为了计算校验和。</p><h3 id="udp校验和"><a class="markdownIt-Anchor" href="#udp校验和"></a> UDP校验和</h3><p>检查数据传输中是否发生错误，默认情况下只检验数据报头，不检验数据。<br /><img src="https://blog-medias.cdn.bcebos.com/posts/Computer_Network/Transport_layer/3.png" alt="校验和标准" /></p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Computer_Network/Transport_layer/4.png" alt="UDP校验和计算示例" /></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Polish Notation</title>
      <link href="/Reverse%20Polish%20Notation.html"/>
      <url>/Reverse%20Polish%20Notation.html</url>
      
        <content type="html"><![CDATA[<p>基本概念就不多介绍了，直接开始介绍思路以及容易踩的坑。</p><h3 id="思路要点"><a class="markdownIt-Anchor" href="#思路要点"></a> 思路要点</h3><h4 id="1-整个过程建立在栈的基础上实现"><a class="markdownIt-Anchor" href="#1-整个过程建立在栈的基础上实现"></a> 1. 整个过程建立在栈的基础上实现。</h4><ul><li><p>需要准备的栈相关的函数：<br />Push: 压栈<br />Pop: 弹栈<br />Top: 查看栈顶元素<br />isEmpty: 判断栈是否为空</p></li><li><p>建议用数组结构实现栈的结构体声名，书上说这样更符合未来实际开发。<br />关于实现方式的细节可以查看： <a href="https://www.cnblogs.com/tomato0906/articles/4620772.html" target="_blank" rel="noopener">三种栈的实现方式</a></p></li></ul><h4 id="2-我们需要准备一个栈和两个字符型的数组"><a class="markdownIt-Anchor" href="#2-我们需要准备一个栈和两个字符型的数组"></a> 2. 我们需要准备一个栈和两个<strong>字符型</strong>的数组</h4><ul><li>准备的栈的目的是改变原中缀表达式中符号的出场顺序，以一种适合计算机运算的出场顺序（后缀表达式）让计算机得到结果。<strong>这个栈内只能进出运算符号，跟数字没关系。</strong></li><li>第一个字符组用来记录用户输入的中缀表达式  “input”<br />第二个字符组用来记录用户输出的后缀表达式  “Postfix”</li></ul><h4 id="3-清晰划分各种符号的等级"><a class="markdownIt-Anchor" href="#3-清晰划分各种符号的等级"></a> 3. 清晰划分各种符号的等级</h4><p>等级用于决定一个新的符号即将入栈时是否将符号栈中的原有的符号弹出</p><ul><li>level 2     <kbd>*</kbd> 和 <kbd>/</kbd></li><li>level 1     <kbd>+</kbd> 和 <kbd>-</kbd></li><li>level 0     <kbd>(</kbd> 和 <kbd>)</kbd></li></ul><h4 id="4-中缀表达式的读取"><a class="markdownIt-Anchor" href="#4-中缀表达式的读取"></a> 4. 中缀表达式的读取</h4><ul><li>读到数字直接写入后缀表达式 Postfix 的字符组</li><li>读到字符(运算符)将字符交给处理字符比较的函数 “OperatorCmp”</li></ul><h4 id="5-operatorcmp-字符比较"><a class="markdownIt-Anchor" href="#5-operatorcmp-字符比较"></a> 5. OperatorCmp 字符比较</h4><ul><li><p>传入两个参数 now 和 check<br />now 是在读取中缀表达式时识别到的字符，也是即将入栈的字符。<br />check 是通过Top函数返回的栈顶的元素。<br />这个函数目的在于通过now的级别和运算符种类，决定下一步栈中元素的动态。</p></li><li><p><strong>栈中元素的改变</strong>(按照优先级顺序叙述,用else if)</p><ul><li>第一种情况：栈中没有元素，第一个运算符直接入栈（这种情况要在函数外进行特殊情况处理，因为函数需要传入栈顶元素值，栈空时强制传入值可能造成数组越界）</li><li>第二种情况：now是<kbd>(</kbd>，直接将now压栈</li><li>第三种情况：now是<kbd>)</kbd>，在阐述完后两种情况后再回来讲述。</li><li>第四种情况：now.level &lt;= check.level<br />意味着这是<kbd>*</kbd>或<kbd>/</kbd>，这里我们要和栈顶元素进行比较。<br /><strong>如果 now.level &lt;= check.level 我们要将栈顶元素弹栈，将弹栈元素加入 Postfix 字符组中。</strong><br />这还没完！我们的比较还没有结束，根据后缀表达式的定义，我们很有可能掉进只将前面一个元素弹出的<strong>坑</strong>，我们的比较只有两个等级而且最后我们还会执行统一清栈的操作，如果这个位置不连续对栈顶元素进行比较，会将本该在这部分弹栈的元素在最后清栈的操作中弹出,由于我们只有两个等级，所以对最终计算结果没有影响，但如果等级变多(例如出现了^)或者某个OJ要求你输出后缀表达式，那就GG了。（测试:2 + 3 * 4 - 5  结果: 2 3 4 * + 5 -）<br /><strong>所以，我们要循环多次比较栈顶元素，直到 now.level &gt; check.level 循环跳出。</strong><br />最后不要忘记，将now压栈！结束。</li><li>第五种情况：now.level &gt; check.level<br />将now压栈，结束。</li><li>回过头来我们介绍第三种情况。识别到<kbd>)</kbd>时，我们应该做的操作是循环弹栈，直到识别到栈顶元素是<kbd>(</kbd>，那么问题来了，我们需不需像第四种和第五种情况一样考虑栈顶元素的等级决定是否弹栈呢？答案是不用，后括号前的元素已经帮你解决了这个难题，不然我们又要开启递归了。每个压栈元素触发的比较已经可以保证<strong>逆序弹栈此时栈中剩余元素，将弹栈元素加入 Postfix 字符组中</strong>就可以正常生成后缀表达式。<br />所以我们要做的操作就是识别到<kbd>(</kbd>之前，循环弹栈。<br />循环结束后完成。</li></ul></li></ul><p><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/Reverse_Polish_Notation/1.png" alt="示例" /></p><h4 id="6-清空字符栈"><a class="markdownIt-Anchor" href="#6-清空字符栈"></a> 6. 清空字符栈</h4><ul><li>将中缀表达式读取完后，后缀表达式 Postfix 还没有生成完毕，因为栈中会有剩余运算符元素，此处的处理方法等同于上面的第三种情况，可以想象将用户输入的中缀表达式两侧加上括号，自然解决办法相同。<br /><strong>逆序弹栈此时栈中剩余元素，将弹栈元素加入 Postfix 字符组中。</strong><br />至此完成全部操作。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>这里是一个要求根据中缀表达式生成后缀表达式并计算出结果的结果代码。以供参考。有一些细节写的繁琐的是因为适应我们校奇怪的oj系统…</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Operator</span>{</span>    <span class="hljs-keyword">char</span> moperator;    <span class="hljs-keyword">int</span> level;}Operator;Operator op[<span class="hljs-number">10</span>];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span>{</span>    Operator opNodes[<span class="hljs-number">100000</span>];    <span class="hljs-keyword">int</span> top;}LinkStack;LinkStack opstack;<span class="hljs-keyword">char</span> Postfix[<span class="hljs-number">100000</span>];<span class="hljs-keyword">int</span> PostfixNum = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitOperater</span><span class="hljs-params">()</span></span>{    op[<span class="hljs-number">0</span>].moperator = <span class="hljs-string">'+'</span>;    op[<span class="hljs-number">0</span>].level = <span class="hljs-number">1</span>;    op[<span class="hljs-number">1</span>].moperator = <span class="hljs-string">'-'</span>;    op[<span class="hljs-number">1</span>].level = <span class="hljs-number">1</span>;    op[<span class="hljs-number">2</span>].moperator = <span class="hljs-string">'*'</span>;    op[<span class="hljs-number">2</span>].level = <span class="hljs-number">2</span>;    op[<span class="hljs-number">3</span>].moperator = <span class="hljs-string">'/'</span>;    op[<span class="hljs-number">3</span>].level = <span class="hljs-number">2</span>;    op[<span class="hljs-number">4</span>].moperator = <span class="hljs-string">'('</span>;    op[<span class="hljs-number">4</span>].level = <span class="hljs-number">0</span>;    op[<span class="hljs-number">5</span>].moperator = <span class="hljs-string">')'</span>;    op[<span class="hljs-number">5</span>].level = <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">stack</span>.top == <span class="hljs-number">-1</span>);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-built_in">stack</span>.top--;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>, Operator pushed)</span></span>{    <span class="hljs-built_in">stack</span>.top++;    <span class="hljs-built_in">stack</span>.opNodes[<span class="hljs-built_in">stack</span>.top] = pushed;}<span class="hljs-function">Operator <span class="hljs-title">Top</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.opNodes[<span class="hljs-built_in">stack</span>.top];}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operatorCmp</span><span class="hljs-params">(LinkStack &amp;opstack,Operator now,Operator check)</span></span>{    <span class="hljs-keyword">if</span>(now.moperator == <span class="hljs-string">'('</span>){        push(opstack,now);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now.moperator == <span class="hljs-string">')'</span>){        now = Top(opstack);        pop(opstack);        check = Top(opstack);        <span class="hljs-keyword">while</span>(check.moperator != <span class="hljs-string">'('</span>){            Postfix[PostfixNum] = now.moperator;            PostfixNum++;            pop(opstack);            now = check;            check = Top(opstack);        }        Postfix[PostfixNum] = now.moperator;        PostfixNum++;        pop(opstack);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(check.level &gt;= now.level){       <span class="hljs-keyword">while</span>(check.level &gt;= now.level){        Postfix[PostfixNum] = check.moperator;        PostfixNum++;        pop(opstack);        <span class="hljs-keyword">if</span>(isEmpty(opstack))<span class="hljs-keyword">break</span>;        check = Top(opstack);   }        push(opstack,now);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(check.level &lt; now.level)        push(opstack,now);}<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">FindSolution</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* Postfix)</span></span>{    <span class="hljs-keyword">double</span> Digit[<span class="hljs-number">100000</span>];    <span class="hljs-keyword">int</span> DigitNum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PostfixNum;i++){        <span class="hljs-keyword">if</span>(Postfix[i]&gt;=<span class="hljs-string">'0'</span>&amp;&amp;Postfix[i]&lt;=<span class="hljs-string">'9'</span>){            Digit[DigitNum] = Postfix[i]-<span class="hljs-string">'0'</span>;            DigitNum++;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'+'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second+first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'-'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second-first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'*'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second*first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'/'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second/first;            DigitNum--;        }    }    <span class="hljs-keyword">return</span> Digit[<span class="hljs-number">0</span>];}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    InitOperater();    opstack.top = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(s[i]!=<span class="hljs-string">'\0'</span>){        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'0'</span>&amp;&amp;s[i] &lt;= <span class="hljs-string">'9'</span>) {            Postfix[PostfixNum] = s[i];            PostfixNum++;        }        <span class="hljs-keyword">else</span>{            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= <span class="hljs-number">5</span>; j++){                <span class="hljs-keyword">if</span> (s[i] == op[j].moperator){                <span class="hljs-keyword">if</span>(!isEmpty(opstack))operatorCmp(opstack,op[j],Top(opstack));                <span class="hljs-keyword">else</span> push(opstack,op[j]);                }            }        }        i++;    }    <span class="hljs-keyword">while</span>(!isEmpty(opstack)){        Postfix[PostfixNum] = Top(opstack).moperator;        PostfixNum++;        pop(opstack);    }    <span class="hljs-keyword">double</span> solution = FindSolution(Postfix);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf\n"</span>,solution);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PostfixNum;i++){        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>,Postfix[i]);    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to the Android</title>
      <link href="/Introduction%20to%20the%20Android.html"/>
      <url>/Introduction%20to%20the%20Android.html</url>
      
        <content type="html"><![CDATA[<h3 id="安卓应用开发特色"><a class="markdownIt-Anchor" href="#安卓应用开发特色"></a> 安卓应用开发特色</h3><ul><li><p>四大组件<br />Activity，Service，Broadcast Receiver，Content Provider</p></li><li><p>SQLite 数据库<br />轻量级，运算速度极快的嵌入式关系型数据库，不仅支持sql语句，还可以通过安卓封装好的API进行操作，让存储和读取数据变得特别方便。</p></li><li><p>地理位置定位<br />Android手机都内置GPS，结合强大的地图功能，LBS这一领域潜力无限。</p></li><li><p>需要准备的工具：<br />️Java JDK<br />️Android SDK<br />️Android Studio</p></li><li><p>Project结构模式下目录介绍：<br />无需更改区域：<br />①  .gradle &amp; .idea 自动生成文件<br />️② build 编译时自动生成的文件<br />③ gradle<br />。。。一堆，不过多赘述</p></li><li><p>开发者设计区域【app文件夹下】</p></li></ul><ol><li><p>build<br />无需关心</p></li><li><p>libs<br />使用到的第三方jar包都会放在libs目录下，放在这个目录下的jar包就会自动被添加到构建路径中去。</p></li></ol><p>️3. android Test<br />此处是用来编写Android Test 测试用例用的</p><p>️4. java<br />毫无疑问，所有java代码放置到该目录下</p><p>️5. res<br />项目中使用到过的所有图片、布局、字符串等资源都要存放在这个目录下。<br />①图片放在drawable目录下<br />②布局放在layout目录下<br />③字符串放在valves目录下</p><ol start="6"><li><p>AndroidManifest.xml<br />这是整个Android项目的配置文件，程序中定义的四大组件都要在这个文件中注册，另外还可以再择个文件中给应用程序添加应用权限声明。</p></li><li><p>test<br />自动化测试</p></li></ol><p>️8. build.gradle<br />这是app模块的gradle构建脚本，这个文件会制定很多项目构建相关的配置</p><ol start="9"><li><a href="http://proguard-rules.pro" target="_blank" rel="noopener">proguard-rules.pro</a><br />代码打包后如果不希望别人进行破解，通过这个文件让代码混淆，从而让阅读者难以阅读</li></ol><h3 id="androidmanifestxml"><a class="markdownIt-Anchor" href="#androidmanifestxml"></a> AndroidManifest.xml</h3><p>首先了解一下<strong>AndroidManifest.xml</strong>文件的这个部分，从中可以找到这段代码：</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/1.png" alt="image" /></p><p>这段代码用于对MainActivity这个活动进行注册，没有在AndroidMainfest内注册的活动是不能使用的。</p><p>往下出现两个<intent-filter>,其中的内容非常重要</p><p>这两行加起来的总效果就是MainActivity是这个项目的总活动，所谓总活动就是点击应用图标后进入的第一个活动。</p><p>标识符【.Main】</p><h3 id="mainactivityjava"><a class="markdownIt-Anchor" href="#mainactivityjava"></a> MainActivity.java</h3><p>接下来看一下这段<strong>MainActivity.java</strong>中的代码，这是安卓四大组件中活动的代码。</p><p>凡是在应用中看得到的东西都是要放在Activity中的。</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/2.png" alt="MainActivity.java" /></p><p>首先要注意MainActivity是继承AppCompatActivity类的，这是一种向下兼容的Activity</p><p>可以将Activity在各个版本中增加的特性和功能最低兼容到Android 2.1系统</p><p><strong>Activity是Android系统提供的一个活动基类，我们项目中的所有活动必须继承它或者他的子类才能拥有活动特性。</strong></p><p>这里AppCompatActivity就是Activity的子类。</p><p>然后注意到MainActivity中存在的**onCreate()**方法</p><p><strong>这个方法是一个活动被创建时必须要执行的方法</strong></p><p>注意onCreate函数中第二行代码：<strong>setContentView（R.layout.activity_main);</strong></p><p>在这里我们要了解Android程序的设计其实是逻辑和视图是分离的</p><p>因此通用的做法是：<strong>在布局文件中编写界面，然后在活动中引进来</strong></p><p>那么在此处就是这个<strong>setContentView()<strong>方法给当前的活动引入了一个</strong>main_activity</strong>布局。</p><p>布局文件都定义在<strong>res/layout</strong>目录下，activity_main.xml文件中你能看到以下代码：</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/3.png" alt="TextView" /></p><p>**android:text=“Hello World!”;**便是HelloWorld的出处。</p><h3 id="buildgradle"><a class="markdownIt-Anchor" href="#buildgradle"></a> build.gradle</h3><p>接下来我们来了解一下<strong>build.gradle</strong>这个文件。</p><p>不同于Eclipse，Android Studio是采用Gradle来构建项目的。</p><p>Gradle是一个非常先进的项目构建工具</p><p>它使用了一种基于Groovy（我也不知道这是啥，厉害就完事了）的领域特定语言（DSL）来声明项目设置</p><p>摒弃了传统基于XML的各种繁琐配置。</p><p>仔细观察会发现有两个<strong>build.gradle</strong>文件，一个是最外层的，一个是app目录下的。</p><p>先讨论最外层的<strong>build.gradle文件</strong></p><p>这些代码都时自动生成的，虽然与法比较难，只看最关键的部分，难度不大。</p><p>两处repositories闭包中都声明了**jcenter()**这行配置</p><p>**jcenter()**其实是一个代码管理仓库</p><p>很多Android开源项目都会将代码托管到jcenter上</p><p>声明了这行配置之后，我们就可以轻松地引用任何jcenter上的开源项目了。</p><p>接下来，dependencies闭包中使用了classpath声明了一个Gradle插件。</p><p>声明这个插件的意义在于Gradle不仅仅服务于Android项目，还有Java，C++等。</p><p>因而我们想要使用它就需要声明此插件。</p><p>这样外层<strong>build.gradle</strong>文件中的要点就分析完了，通常情况下并不需要修改这个文件中的内容。</p><p>除非你想添加全局的项目构建配置。</p><p>再来看一下app目录下的<strong>build.gradle</strong>文件：</p><p>我们来一行一行分析：</p><p>首先第一行应用了一个插件，一般有两种值可以选：</p><p>① <strong>com.android.application</strong> 表示这是一个应用程序模块。</p><p>② **com.android.library **表示这是一个库模块。</p><p>应用程序模块和库模块的最大差别在于，应用程序模块是可以直接运行的，而库模块只能作为依附于别的应用程序模块来进行。</p><h3 id="android闭包"><a class="markdownIt-Anchor" href="#android闭包"></a> <strong>android闭包</strong></h3><p>在这个闭包中，我们可以配置项目构建的各种属性，同样在编辑器或者SDK更新的时候编译器出现故障时，这里也是故障发生的集中地。</p><p>1.** compileSdkVersion** 用于指定项目的编译版本。</p><p>2.** buildToolVersion** 用于指定项目构建工具的版本。</p><p>3. **defaultConfig ** <strong>闭包</strong></p><p>在这个闭包中可以对项目中的更多细节进行配置，其中</p><p>① applicationID 用于指定项目的包名，在创建项目的时候应该已经指定过包名了，如果想更改，要在这里更改。</p><p>② minSdkVersion 用于指定项目最低兼容的Android系统版本</p><p>③ targetSdkVersion 指定的值表示你在该目标版本上已经做了充分的测试，如果测试的版本号较低，较高版本的某些运行时功能权限不会对App开放</p><p>④ versionCode &amp; versionName 用于指定项目的版本号和版本名，这两个文件在生成安装文件的时候非常重要！</p><p>4. <strong>buildTypes 闭包</strong></p><p>用于指定生成安装文件的相关配置，通常只会由两个子闭包，一个是debug，另一个是release。</p><p>debug闭包用于制定生成测试版安装文件的配置，<strong>可以忽略不写的</strong></p><p>release闭包用于指定生成正式版安装文件的配置，下面详细介绍一下。</p><p>① minifyEnabled 用于指定是否对项目的代码进行了混淆（加密）</p><p>② proguardFiles 用于指定混淆时的规则文件，这里指定了两个文件：</p><p>第一个 proguard-android.txt 是在Android SDK目录下的，里面是所有项目通用的混淆规则</p><p>第二个 <a href="http://proguard-rules.pro" target="_blank" rel="noopener">proguard-rules.pro</a> 是在当前项目根目录下的，里面可以编写当前项目的特有的混淆规则</p><p>这样，整个 <strong>android 闭包</strong> 中的内容就都分析完了。</p><h3 id="dependencies-闭包"><a class="markdownIt-Anchor" href="#dependencies-闭包"></a> dependencies 闭包</h3><p>接下来还剩一个 <strong>dependencies 闭包</strong>，这个闭包非常强大，它可以指定当前项目所有的依赖关系</p><p>通常 Android Studio 项目一共有三种依赖类型：本地依赖、库依赖、远程依赖。</p><p><strong>本地依赖</strong>可以对本地的 jar包 或者 目录 添加依赖关系</p><p><strong>库依赖</strong>可以对项目中的库模块添加依赖关系</p><p><strong>远程依赖</strong>可以对 jcenter 库上的开源项目添加依赖关系。</p><h4 id="dependencies-闭包中的配置"><a class="markdownIt-Anchor" href="#dependencies-闭包中的配置"></a> dependencies 闭包中的配置</h4><p>1. compile fileTree</p><p>是一个本地依赖声明，它表示将libs目录下所有 .jar 后缀的文件都添加到项目的构建路径当中。</p><p>2. compile</p><p>是远程依赖声明，后边标明远程依赖库、域名、组名称、版本号。</p><h3 id="安卓日志工具-log"><a class="markdownIt-Anchor" href="#安卓日志工具-log"></a> <strong>安卓日志工具 Log：</strong></h3><p>1. Log.v() 用于打印那些最为琐碎的，意义最小的日志信息，对应级别verbose。日志级别最低</p><p>2. Log.d() 用于打印一些调试信息，调试程序常用，对应级别debug，比verbose高级一些</p><p>3. Log.i() 用于打印一些比较重要的数据，这些数据是开发者非常想要看到的、可以帮你分析数据行为数据。对应级别info，比debug级别高一些</p><p>4. Log.w() 用于打印一些警告信息，提示程序在这个地方可能会出现一些潜在的风险，最好去修复一下这些出现警告的地方，对应级别warn，比info高一级</p><p>5. Log.e() 用于打印程序中的错误信息，比如程序进入到了catch语句中，当有错误信息打印出来的时候，一般都代表你的程序出现了严重错误，对应级别error，比warn高一级</p><p>如图所示，可以根据等级筛选日志。</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/4.png" alt="image" /></p><p>我们在MainActivity.java中加入此调试代码</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/5.png" alt="image" /></p><p>Log.d(tag,msg); 调试方法有两个参数，第一个是标签，第二个是调试信息。</p><p>此处关于标签要强调，logcat中可以很轻松地添加过滤器。</p><p>下图是系统给的默认过滤器</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/6.png" alt="image" /></p><p>接下来就让我们尝试自己创建一个过滤器，点击上图中的Edit Filter Configuration，出现下图创建界面，</p><p>给filter起名后，通过更改Lag Tag为“data”（自定义），再将调试信息第一个参数改为data即可实现只显示特定调试。</p><p><img src="https://blog-medias.cdn.bcebos.com/posts/Android/Android_Introduction/7.png" alt="image" /></p><p>日记级别控制的好处就是能方便快捷地找到你所关心的那些日志。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL Tree</title>
      <link href="/AVL%20Tree.html"/>
      <url>/AVL%20Tree.html</url>
      
        <content type="html"><![CDATA[<p>注：本篇的介绍风格会偏笔记向，如果第一次接触AVL树实现，看完本文关于旋转实现的思想还未完全理解，可以看看下面我比较推荐的教程，也作为作者本文的参考博客。<br /><a href="https://b23.tv/av51157423/p1" target="_blank" rel="noopener">AVL树从入门到入土（B站视频 “看完还不懂可以选择弃疗” ）</a></p><p>下面步入正题：</p><h2 id="avl树基本概念"><a class="markdownIt-Anchor" href="#avl树基本概念"></a> AVL树基本概念</h2><ul><li>中文名称：平衡二叉树</li><li>结构特点：树中的任意节点的左右子树的高度之差不超过1的<strong>二叉搜索树</strong></li><li>实现核心操作：查询、插入、删除、旋转</li><li>时间复杂度：查询、插入、删除的时间复杂度均为O(logn)</li></ul><h2 id="avl模块化实现"><a class="markdownIt-Anchor" href="#avl模块化实现"></a> AVL模块化实现</h2><h3 id="结构体声明"><a class="markdownIt-Anchor" href="#结构体声明"></a> 结构体声明</h3><pre class="highlight"><code class="C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>{</span>    <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">int</span> balance;    AVLNode* left;    AVLNode* right;    AVLNode* parent;};<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLTree</span>{</span>    AVLNode* root;}tree;</code></pre><ul><li>平衡因子BF（Balanced Factor）:该结点的左子树与右子树的高度之差的值。在每个节点中都要附有这样一个标签。</li><li>平衡的识别条件：根据AVL的定义，树中的任意节点的左右子树的高度之差不超过 1。所以，AVL树中的任意结点的平衡因子只可能是：<br />① -1（右子树高于左子树）<br />② 0 （左右子树高度相等）<br />③ 1 （左子树高于右子树）<br />如果因为插入新的节点或删除某一个节点使某个其他节点的BF值变为-2或2，则视为当前状态为不平衡的状态，那么就要通过旋转操作来使其恢复平衡。<br />那么接下来获取高度的方法和二叉搜索树是一样的。</li></ul><h3 id="二叉排序树基本操作"><a class="markdownIt-Anchor" href="#二叉排序树基本操作"></a> 二叉排序树基本操作</h3><h4 id="递归查询即将要插入删除的节点位置"><a class="markdownIt-Anchor" href="#递归查询即将要插入删除的节点位置"></a> 递归查询即将要插入/删除的节点位置</h4><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    <span class="hljs-keyword">if</span>(root==<span class="hljs-number">0</span>){        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">if</span>(root-&gt;value==value){        <span class="hljs-keyword">return</span> root;    }    <span class="hljs-keyword">if</span>(root-&gt;value&gt;value){        <span class="hljs-keyword">if</span>(root-&gt;left)            <span class="hljs-keyword">return</span> select(value,root-&gt;left);        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> root;    }    <span class="hljs-keyword">if</span>(root-&gt;value&lt;value){        <span class="hljs-keyword">if</span>(root-&gt;right)            <span class="hljs-keyword">return</span> select(value,root-&gt;right);        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> root;    }}</code></pre><p>select函数要点：</p><ul><li>这段代码select函数将插入和删除功能中要进行的递归查询操作封装在了一起</li><li>考虑空树情况，返回值为0</li><li>如果value参数值与查询节点的value值相等，返回该节点。这部操作是为删除操作服务的。</li><li>如果value参数值比查询节点值大/小，递归得到该节点的右/左节点的select函数返回值，如果被查询子节点为NULL，则返回该节点，在insert函数中生成新的子节点。</li></ul><h4 id="插入新节点"><a class="markdownIt-Anchor" href="#插入新节点"></a> 插入新节点</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    AVLNode* node=select(value,root); <span class="hljs-comment">// 找到即将被插入的目标节点</span>    <span class="hljs-keyword">if</span>(node==<span class="hljs-number">0</span>){  <span class="hljs-comment">// 如果树为空</span>        tree.root=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));        tree.root-&gt;value=value;        tree.root-&gt;left=tree.root-&gt;right=<span class="hljs-number">0</span>;        tree.root-&gt;parent=<span class="hljs-number">0</span>;        tree.root-&gt;balance=<span class="hljs-number">0</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;value!=value){        <span class="hljs-keyword">if</span>(node-&gt;value&gt;value){            node-&gt;left=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));            node-&gt;left-&gt;value=value;            node-&gt;left-&gt;left=node-&gt;left-&gt;right=<span class="hljs-number">0</span>;            node-&gt;left-&gt;parent=node;            node-&gt;left-&gt;balance=<span class="hljs-number">0</span>;            rebalance(node);        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;value&lt;value){            node-&gt;right=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));            node-&gt;right-&gt;value=value;            node-&gt;right-&gt;left=node-&gt;right-&gt;right=<span class="hljs-number">0</span>;            node-&gt;right-&gt;parent=node;            node-&gt;right-&gt;balance=<span class="hljs-number">0</span>;            rebalance(node);        }    }}</code></pre><p>Insert函数要点：</p><ul><li>考虑空树情况</li><li>通过递归比较树中的节点并插入（这里通过select函数找到被插入节点后再insert函数体内再次进行左右树判断之所以略显繁琐，是为了方便删除节点时复用select函数体内逻辑。）</li><li>[AVL树] <strong>检测并恢复平衡</strong>：rebalance函数。</li></ul><h4 id="删除某一节点"><a class="markdownIt-Anchor" href="#删除某一节点"></a> 删除某一节点</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    AVLNode* node=select(value,root);    <span class="hljs-keyword">if</span>(node-&gt;value==value){        <span class="hljs-keyword">if</span>(node-&gt;left&amp;&amp;node-&gt;right){            delete_Twochild(node);        }<span class="hljs-keyword">else</span>{            delete_NotTwochild(node);        }    }}</code></pre><p>delete函数要点：</p><ul><li>通过select函数递归查找被删除节点，节省效率。</li><li>考虑被删除节点子树个数的情况：<ol><li>有两个子树</li><li>有一个或没有子树</li></ol></li></ul><h5 id="被删除节点有一个子树或没有子树的情况"><a class="markdownIt-Anchor" href="#被删除节点有一个子树或没有子树的情况"></a> 被删除节点有一个子树或没有子树的情况</h5><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_NotTwochild</span><span class="hljs-params">(AVLNode* node)</span></span>{    <span class="hljs-keyword">if</span>(node-&gt;parent==<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(node-&gt;left){            tree.root=node-&gt;left;            node-&gt;left-&gt;parent=<span class="hljs-number">0</span>;        }<span class="hljs-keyword">else</span>{            tree.root=node-&gt;right;            node-&gt;right-&gt;parent=<span class="hljs-number">0</span>;        }    }<span class="hljs-keyword">else</span>{        <span class="hljs-keyword">if</span>(node-&gt;parent-&gt;left==node){            <span class="hljs-keyword">if</span>(node-&gt;left){                node-&gt;parent-&gt;left=node-&gt;left;                node-&gt;left-&gt;parent=node-&gt;parent;            }<span class="hljs-keyword">else</span>{                node-&gt;parent-&gt;left=node-&gt;right;                <span class="hljs-keyword">if</span>(node-&gt;right)                    node-&gt;right-&gt;parent=node-&gt;parent;            }        }<span class="hljs-keyword">else</span>{            <span class="hljs-keyword">if</span>(node-&gt;left){                node-&gt;parent-&gt;right=node-&gt;left;                node-&gt;left-&gt;parent=node-&gt;parent;            }<span class="hljs-keyword">else</span>{                node-&gt;parent-&gt;right=node-&gt;right;                <span class="hljs-keyword">if</span>(node-&gt;right)                    node-&gt;right-&gt;parent=node-&gt;parent;            }        }        rebalance(node-&gt;parent);    }}</code></pre><p>delete_NotTwochild函数要点：</p><ul><li>如果删除节点子节点数量为0或1,执行该函数。</li><li>要考虑到被删除节点是根节点的情况，因为要避免root-&gt;parent为空指针的情况。</li><li>通过node-&gt;parent-&gt;left == node的方式判断该节点是父节点的左孩子还是右孩子。</li><li>先判断出该节点是其父亲节点的左子树还是右子树，方便在删除操作后将目标删除节点的父亲节点的孩子指针指向目标删除节点的孩子节点。</li><li>然后判断目标删除节点的孩子在左子树还是右子树还是不存在。</li><li>不管哪种情况，将目标删除节点的父亲节点的孩子指针指向目标删除节点的孩子节点。</li><li>下一步要将目标删除节点的孩子节点的父亲指针指向删除节点的父亲节点，考虑到目标删除节点没有孩子的情况会导致node-&gt;left-&gt;parent出现空指针情况。所以要在这部之前先判断删除节点是否有孩子。</li><li>[AVL树]完成二叉排序树的基本删除操作后，<strong>检查并恢复平衡</strong>，rebalance函数。</li></ul><pre class="highlight"><code class="">void delete_Twochild(AVLNode* node){    AVLNode* after=getMin(node-&gt;right);    node-&gt;value=after-&gt;value;    delete_NotTwochild(after);}</code></pre><p>delete_Twochild函数要点：</p><ul><li>如果删除节点有两个子节点，执行该函数。</li><li>这种情况只需要在删除节点的右子树中通过getMin函数寻找到value值最小的节点，将删除节点的值与其互换，再将找到的最小value值的节点通过delete_NotTwochild函数删除。</li></ul><pre class="highlight"><code class="">struct AVLNode* getMin(AVLNode* node){    if(node-&gt;left)        getMin(node-&gt;left);    else        return node;}</code></pre><p>getMin函数要点：</p><ul><li>此函数目的在于寻找某一节点作为根节点的树中value值最小的节点。</li><li>根据二叉排序树，递归查找最左侧节点即可。</li></ul><p>至此，二叉排序树基本操作介绍完成。</p><h3 id="avl树旋转操作"><a class="markdownIt-Anchor" href="#avl树旋转操作"></a> AVL树旋转操作</h3><h4 id="获取高度"><a class="markdownIt-Anchor" href="#获取高度"></a> 获取高度</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AVLNode* a)</span></span>{    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>){        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">int</span> rightheight = height(a-&gt;right);    <span class="hljs-keyword">int</span> leftheight = height(a-&gt;left);    <span class="hljs-keyword">return</span> rightheight &gt; leftheight ? (rightheight+<span class="hljs-number">1</span>) : (leftheight+<span class="hljs-number">1</span>);}</code></pre><p>height函数要点：</p><ul><li>考虑空树情况。</li><li>分别递归查询左右子树高度，层层递归向上返回高度累加值。</li></ul><h4 id="检查并回复平衡"><a class="markdownIt-Anchor" href="#检查并回复平衡"></a> 检查并回复平衡</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rebalance</span><span class="hljs-params">(AVLNode* a)</span></span>{    setBalance(a);    <span class="hljs-keyword">if</span>(a-&gt;balance== <span class="hljs-number">-2</span>){        <span class="hljs-keyword">if</span>(a-&gt;left-&gt;balance &lt;=<span class="hljs-number">0</span>){            a=turnRight(a);        }<span class="hljs-keyword">else</span>{            a=turnLeftThenRight(a);        }    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a-&gt;balance==<span class="hljs-number">2</span>){        <span class="hljs-keyword">if</span>(a-&gt;right-&gt;balance&gt;=<span class="hljs-number">0</span>){            a=turnLeft(a);        }<span class="hljs-keyword">else</span>{            a=turnRightThenLeft(a);        }    }    <span class="hljs-keyword">if</span>(a-&gt;parent){        rebalance(a-&gt;parent);    }<span class="hljs-keyword">else</span>{        tree.root=a;    }}</code></pre><ul><li>首先通过setBalance函数刷新被检查节点的balance值。</li><li>开始检查节点balance值：分为四种不平衡情况，对应以下四种旋转方案。</li><li>递归向父亲节点递归检查，直到查到根节点。</li></ul><h4 id="刷新节点balance值"><a class="markdownIt-Anchor" href="#刷新节点balance值"></a> 刷新节点balance值</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBalance</span><span class="hljs-params">(AVLNode* a)</span></span>{    <span class="hljs-keyword">if</span>(a)        a-&gt;balance=height(a-&gt;right)-height(a-&gt;left);}</code></pre><h4 id="单次旋转向左右旋转"><a class="markdownIt-Anchor" href="#单次旋转向左右旋转"></a> 单次旋转（向左/右旋转）</h4><p><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/AVL/AVL1.png" alt="Turn Left" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnLeft</span><span class="hljs-params">(AVLNode* a)</span></span>{    AVLNode* b=a-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }    b-&gt;parent=a-&gt;parent;    a-&gt;parent=b;    a-&gt;right=b-&gt;left;    b-&gt;left=a;    <span class="hljs-keyword">if</span>(a-&gt;right!=<span class="hljs-number">0</span>)        a-&gt;right-&gt;parent=a;    setBalance(a);    setBalance(b);    <span class="hljs-keyword">return</span> b;}</code></pre><p><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/AVL/AVL2.png" alt="Turn Right" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnRight</span><span class="hljs-params">(AVLNode* a)</span></span>{    AVLNode* b=a-&gt;left;    <span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }    b-&gt;parent=a-&gt;parent;    a-&gt;left=b-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;left!=<span class="hljs-number">0</span>)        a-&gt;left-&gt;parent=a;    a-&gt;parent=b;    b-&gt;right=a;    setBalance(a);    setBalance(b);    <span class="hljs-keyword">return</span> b;}</code></pre><p><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/AVL/AVL3.jpg" alt="Turn Right 举例" /></p><p>单次旋转函数要点：</p><ul><li>单次旋转函数触发条件：<br />Turn Right： node-&gt;balance = -2 &amp;&amp; node-&gt;left-&gt;balance &lt;= 0<br />Turn Left：node-&gt;balance = 2 &amp;&amp; node-&gt;right-&gt;balance &gt;= 0</li><li>具体处理步骤：（Turn Right 举例）<br />① 把a节点以及他的右子树移除，a的左子节点b代替a的位置</li></ul><pre class="highlight"><code class="C"><span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }</code></pre><p>②把b节点的右子树移动成为a节点的左子树</p><pre class="highlight"><code class="C">   a-&gt;left=b-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;left!=<span class="hljs-number">0</span>)        a-&gt;left-&gt;parent=a;</code></pre><p>③让a节点成为b节点的右孩子</p><pre class="highlight"><code class="C">    a-&gt;parent=b;    b-&gt;right=a;</code></pre><p>④刷新a,b节点的balance值。<br />⑤return b节点，让rebalance函数重新从b节点向上检查新树的平衡性。</p><h4 id="两次旋转"><a class="markdownIt-Anchor" href="#两次旋转"></a> 两次旋转</h4><p><img src="https://blog-medias.cdn.bcebos.com/posts/DSA/AVL/AVL4.png" alt="Double Rotation" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnLeftThenRight</span><span class="hljs-params">(AVLNode* a)</span></span>{    a-&gt;left = turnLeft(a-&gt;left);    <span class="hljs-keyword">return</span> turnRight(a);}<span class="hljs-function">struct AVLNode* <span class="hljs-title">turnRightThenLeft</span><span class="hljs-params">(AVLNode* a)</span></span>{    a-&gt;right = turnRight(a-&gt;right);    <span class="hljs-keyword">return</span> turnLeft(a);}</code></pre><p>两次旋转函数要点：</p><ul><li>两次旋转函数触发条件：<br />Turn Right Then Left： node-&gt;balance = 2 &amp;&amp; node-&gt;left-&gt;balance = -1<br />Turn Left Then Right：node-&gt;balance = -2 &amp;&amp; node-&gt;right-&gt;balance = 1</li><li>核心实现思路：对不平衡节点的不平衡方向的子节点先做旋转操作，再对不平衡节点做第二次旋转。</li></ul><p>至此，旋转操作介绍完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
