<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS Programs</title>
      <link href="/CSS%E5%88%9B%E6%84%8F%E9%A1%B9%E7%9B%AE.html"/>
      <url>/CSS%E5%88%9B%E6%84%8F%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<h2 id="网页效果目前支持chromeie等浏览器移动端支持safari不支持安卓大部分浏览器"><a class="markdownIt-Anchor" href="#网页效果目前支持chromeie等浏览器移动端支持safari不支持安卓大部分浏览器"></a> 网页效果目前支持Chrome，IE等浏览器，移动端支持Safari,不支持安卓大部分浏览器</h2><ul><li><a href="/projects/Layered-Image-Hover-Effects">Layered Image Hover Effects</a></li><li><a href="/projects/Price-Card-UI-Design">Price Card UI Design</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transport layer</title>
      <link href="/%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8A).html"/>
      <url>/%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8A).html</url>
      
        <content type="html"><![CDATA[<h2 id="传输层概述"><a class="markdownIt-Anchor" href="#传输层概述"></a> 传输层概述</h2><ul><li>应用层协议的消息传输需要可靠性，而仅靠网络层IP不可靠，数据可能会出错、丢失或乱序等异常情况。</li><li>传输层实现端到端的可靠通信</li><li>传输层负责将向目标IP地址发送的消息通过传输层协议中的端口号传入特定进程。</li><li>传输层提供了面向连接的机制：可靠传输、流量控制、拥塞控制。</li><li>传输层不提供时延保障和带宽保障。</li></ul><h3 id="进程之间的通信"><a class="markdownIt-Anchor" href="#进程之间的通信"></a> 进程之间的通信</h3><ul><li>传输层属于面向通信部分的最高层，但也是用户功能中的最底层。</li><li>严格地讲，两台主机进行通信就是两个应用进程在交换数据。所以从传输层的角度看，通信真正的端点并不是IP地址所定位的主机，而是主机中的进程。</li><li>网络层和传输层有着明显区别。网络层为主机之间提供逻辑通信，而运输层为应用之间提供通信。</li></ul><h4 id="传输层重要功能复用和分用"><a class="markdownIt-Anchor" href="#传输层重要功能复用和分用"></a> 传输层重要功能：复用和分用</h4><ol><li><p>复用是指在发送方不同的应用进程中都可以使用同一个传输层协议。<br />源端传输层会在应用层数据前加上源端口号和目标端口号。<br />进程表示：16位端口号</p></li><li><p>分用是指在接收方的传输层剥去报文首部后能够把这些数据正确地交付目标应用进程。</p></li></ol><h4 id="端口号的规定"><a class="markdownIt-Anchor" href="#端口号的规定"></a> 端口号的规定</h4><ol><li>熟知端口（常用端口，Well-known port）<ul><li>服务器进程使用</li><li>开放并且端口号固定</li><li>Web服务器（HTTP）端口一般为80，<br />Telnet服务器端口号一般为23，<br />FTP端口号一般为21，<br />DNS端口号一般为53。</li><li>值一般小于1024</li></ul></li><li>短暂端口<ul><li>用户进程使用</li><li>由操作系统分配，值不固定</li><li>值大于5000</li></ul></li></ol><h2 id="无连接传输协议udp"><a class="markdownIt-Anchor" href="#无连接传输协议udp"></a> 无连接传输协议：UDP</h2><h3 id="udp的概念"><a class="markdownIt-Anchor" href="#udp的概念"></a> UDP的概念</h3><p>又名用户数据报协议，一种简单高效的传输层协议。</p><h3 id="udp的特点"><a class="markdownIt-Anchor" href="#udp的特点"></a> UDP的特点</h3><ol><li><p>UDP是无连接的。<br />即发送数据前不需要建立连接，减少了开销和发送数据的时延。</p></li><li><p>UDP使用最大努力交付。<br />牺牲可靠性。</p></li><li><p>UDP是面向报文的。</p><ul><li>UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。</li><li>UDP对交下来的报文既不合并，也不拆分，而是保留这些报文的边界。（原样发送）</li><li>若报文太长UDP把报文传给IP层后，IP层可能要进行分片，这会降低IP层的效率。</li><li>反之，若报文长度太短，UDP把报文交给IP层会导致首部相对长度太大，也降低了IP层的效率。<br /><img src="/medias/posts/UDP/udp1.png" alt="UDP是面向报文的" /></li></ul></li><li><p>UDP没有拥塞控制<br />因此网络出现的拥塞不会使源主机的发送速率降低，对某些实时应用很重要，他们要求源主机以恒定的速率发送数据，并且允许丢失一些数据，但却不允许有较大的时延。UDP刚好能满足这个需求。</p></li><li><p>UDP支持一对一、一对多、多对一、多对多的交互通信。</p></li><li><p>UDP的首部开销小<br />UDP的首部只有8个字节，比TCP的20个字节的首部要短很多。</p></li></ol><h3 id="udp的应用"><a class="markdownIt-Anchor" href="#udp的应用"></a> UDP的应用</h3><ol><li>虽然实时应用需要没有拥塞控制的UDP，但当很多源主机都同时向网络发送高频率的实时视频流时，网络就有可能发生阻塞，结果就是大家都无法正常接收。因此没有拥塞控制的UDP有可能引起网络产生的严重拥塞问题。</li><li>有一些使用UDP的实时应用，需要对UDP的不可靠的传输进行适当的改进，以减少数据的丢失。可以在不影响应用层的实时性的前提下，增加一些提高可靠性的措施，如采用向前纠错或重传已丢失的报文。</li></ol><ul><li>前向纠错：前向纠错是一种差错控制方式，它是指信号在被送入传输信道之前预先按一定的算法进行编码处理，加入带有信号本身特征的冗码，在接收端按照相应算法对接收到的信号进行解码，从而找出在传输过程中产生的错误码并将其纠正的技术。</li></ul><h3 id="udp的首部格式"><a class="markdownIt-Anchor" href="#udp的首部格式"></a> UDP的首部格式</h3><p>用户数据报有两个字段，数据字段和首部字段，首部字段只有八个字节。由四个字段组成，每个字段都是两个字节，各字段意义：</p><ol><li>源端口号：在需要对方回信时选用，不需要可全用0。</li><li>目的端口号：在终点时交付报文必须需要。</li><li>长度：UDP数据报的长度，其最小值是8。</li><li>检验和：检验UDP在传输过程是否有错，有错就丢弃。</li></ol><p><img src="/medias/posts/UDP/udp2.png" alt="UDP用户数据报的首部部和伪首部" /></p><h3 id="udp的伪首部"><a class="markdownIt-Anchor" href="#udp的伪首部"></a> UDP的伪首部</h3><p>UDP用户数据报的检验方法有一些特殊。在计算校验和时需要在数据报前加上12个字节的伪首部。在计算校验和时临时添加在UDP数据报前面，伪首部既不向下传送也不向上提交，仅仅是为了计算校验和。</p><h3 id="udp校验和"><a class="markdownIt-Anchor" href="#udp校验和"></a> UDP校验和</h3><p>检查数据传输中是否发生错误，默认情况下只检验数据报头，不检验数据。<br /><img src="/medias/posts/UDP/udp3.png" alt="校验和标准" /></p><p><img src="/medias/posts/UDP/udp4.png" alt="UDP校验和计算示例" /></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Polish Notation (Postfix)</title>
      <link href="/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>基本概念就不多介绍了，直接开始介绍思路以及容易踩的坑。</p><h3 id="思路要点"><a class="markdownIt-Anchor" href="#思路要点"></a> 思路要点</h3><h4 id="1-整个过程建立在栈的基础上实现"><a class="markdownIt-Anchor" href="#1-整个过程建立在栈的基础上实现"></a> 1. 整个过程建立在栈的基础上实现。</h4><ul><li><p>需要准备的栈相关的函数：<br />Push: 压栈<br />Pop: 弹栈<br />Top: 查看栈顶元素<br />isEmpty: 判断栈是否为空</p></li><li><p>建议用数组结构实现栈的结构体声名，书上说这样更符合未来实际开发。<br />关于实现方式的细节可以查看： <a href="https://www.cnblogs.com/tomato0906/articles/4620772.html" target="_blank" rel="noopener">三种栈的实现方式</a></p></li></ul><h4 id="2-我们需要准备一个栈和两个字符型的数组"><a class="markdownIt-Anchor" href="#2-我们需要准备一个栈和两个字符型的数组"></a> 2. 我们需要准备一个栈和两个<strong>字符型</strong>的数组</h4><ul><li>准备的栈的目的是改变原中缀表达式中符号的出场顺序，以一种适合计算机运算的出场顺序（后缀表达式）让计算机得到结果。<strong>这个栈内只能进出运算符号，跟数字没关系。</strong></li><li>第一个字符组用来记录用户输入的中缀表达式  “input”<br />第二个字符组用来记录用户输出的后缀表达式  “Postfix”</li></ul><h4 id="3-清晰划分各种符号的等级"><a class="markdownIt-Anchor" href="#3-清晰划分各种符号的等级"></a> 3. 清晰划分各种符号的等级</h4><p>等级用于决定一个新的符号即将入栈时是否将符号栈中的原有的符号弹出</p><ul><li>level 2     <kbd>*</kbd> 和 <kbd>/</kbd></li><li>level 1     <kbd>+</kbd> 和 <kbd>-</kbd></li><li>level 0     <kbd>(</kbd> 和 <kbd>)</kbd></li></ul><h4 id="4-中缀表达式的读取"><a class="markdownIt-Anchor" href="#4-中缀表达式的读取"></a> 4. 中缀表达式的读取</h4><ul><li>读到数字直接写入后缀表达式 Postfix 的字符组</li><li>读到字符(运算符)将字符交给处理字符比较的函数 “OperatorCmp”</li></ul><h4 id="5-operatorcmp-字符比较"><a class="markdownIt-Anchor" href="#5-operatorcmp-字符比较"></a> 5. OperatorCmp 字符比较</h4><ul><li><p>传入两个参数 now 和 check<br />now 是在读取中缀表达式时识别到的字符，也是即将入栈的字符。<br />check 是通过Top函数返回的栈顶的元素。<br />这个函数目的在于通过now的级别和运算符种类，决定下一步栈中元素的动态。</p></li><li><p><strong>栈中元素的改变</strong>(按照优先级顺序叙述,用else if)</p><ul><li>第一种情况：栈中没有元素，第一个运算符直接入栈（这种情况要在函数外进行特殊情况处理，因为函数需要传入栈顶元素值，栈空时强制传入值可能造成数组越界）</li><li>第二种情况：now是<kbd>(</kbd>，直接将now压栈</li><li>第三种情况：now是<kbd>)</kbd>，在阐述完后两种情况后再回来讲述。</li><li>第四种情况：now.level &lt;= check.level<br />意味着这是<kbd>*</kbd>或<kbd>/</kbd>，这里我们要和栈顶元素进行比较。<br /><strong>如果 now.level &lt;= check.level 我们要将栈顶元素弹栈，将弹栈元素加入 Postfix 字符组中。</strong><br />这还没完！我们的比较还没有结束，根据后缀表达式的定义，我们很有可能掉进只将前面一个元素弹出的<strong>坑</strong>，我们的比较只有两个等级而且最后我们还会执行统一清栈的操作，如果这个位置不连续对栈顶元素进行比较，会将本该在这部分弹栈的元素在最后清栈的操作中弹出,由于我们只有两个等级，所以对最终计算结果没有影响，但如果等级变多(例如出现了^)或者某个OJ要求你输出后缀表达式，那就GG了。（测试:2 + 3 * 4 - 5  结果: 2 3 4 * + 5 -）<br /><strong>所以，我们要循环多次比较栈顶元素，直到 now.level &gt; check.level 循环跳出。</strong><br />最后不要忘记，将now压栈！结束。</li><li>第五种情况：now.level &gt; check.level<br />将now压栈，结束。</li><li>回过头来我们介绍第三种情况。识别到<kbd>)</kbd>时，我们应该做的操作是循环弹栈，直到识别到栈顶元素是<kbd>(</kbd>，那么问题来了，我们需不需像第四种和第五种情况一样考虑栈顶元素的等级决定是否弹栈呢？答案是不用，后括号前的元素已经帮你解决了这个难题，不然我们又要开启递归了。每个压栈元素触发的比较已经可以保证<strong>逆序弹栈此时栈中剩余元素，将弹栈元素加入 Postfix 字符组中</strong>就可以正常生成后缀表达式。<br />所以我们要做的操作就是识别到<kbd>(</kbd>之前，循环弹栈。<br />循环结束后完成。</li></ul></li></ul><p>[图片上传失败…(image-dc8890-1571722020497)]</p><h4 id="6-清空字符栈"><a class="markdownIt-Anchor" href="#6-清空字符栈"></a> 6. 清空字符栈</h4><ul><li>将中缀表达式读取完后，后缀表达式 Postfix 还没有生成完毕，因为栈中会有剩余运算符元素，此处的处理方法等同于上面的第三种情况，可以想象将用户输入的中缀表达式两侧加上括号，自然解决办法相同。<br /><strong>逆序弹栈此时栈中剩余元素，将弹栈元素加入 Postfix 字符组中。</strong><br />至此完成全部操作。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>这里是一个要求根据中缀表达式生成后缀表达式并计算出结果的结果代码。以供参考。有一些细节写的繁琐的是因为适应我们校奇怪的oj系统…</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Operator</span>{</span>    <span class="hljs-keyword">char</span> moperator;    <span class="hljs-keyword">int</span> level;}Operator;Operator op[<span class="hljs-number">10</span>];<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span>{</span>    Operator opNodes[<span class="hljs-number">100000</span>];    <span class="hljs-keyword">int</span> top;}LinkStack;LinkStack opstack;<span class="hljs-keyword">char</span> Postfix[<span class="hljs-number">100000</span>];<span class="hljs-keyword">int</span> PostfixNum = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitOperater</span><span class="hljs-params">()</span></span>{    op[<span class="hljs-number">0</span>].moperator = <span class="hljs-string">'+'</span>;    op[<span class="hljs-number">0</span>].level = <span class="hljs-number">1</span>;    op[<span class="hljs-number">1</span>].moperator = <span class="hljs-string">'-'</span>;    op[<span class="hljs-number">1</span>].level = <span class="hljs-number">1</span>;    op[<span class="hljs-number">2</span>].moperator = <span class="hljs-string">'*'</span>;    op[<span class="hljs-number">2</span>].level = <span class="hljs-number">2</span>;    op[<span class="hljs-number">3</span>].moperator = <span class="hljs-string">'/'</span>;    op[<span class="hljs-number">3</span>].level = <span class="hljs-number">2</span>;    op[<span class="hljs-number">4</span>].moperator = <span class="hljs-string">'('</span>;    op[<span class="hljs-number">4</span>].level = <span class="hljs-number">0</span>;    op[<span class="hljs-number">5</span>].moperator = <span class="hljs-string">')'</span>;    op[<span class="hljs-number">5</span>].level = <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">stack</span>.top == <span class="hljs-number">-1</span>);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-built_in">stack</span>.top--;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>, Operator pushed)</span></span>{    <span class="hljs-built_in">stack</span>.top++;    <span class="hljs-built_in">stack</span>.opNodes[<span class="hljs-built_in">stack</span>.top] = pushed;}<span class="hljs-function">Operator <span class="hljs-title">Top</span><span class="hljs-params">(LinkStack &amp;<span class="hljs-built_in">stack</span>)</span></span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.opNodes[<span class="hljs-built_in">stack</span>.top];}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operatorCmp</span><span class="hljs-params">(LinkStack &amp;opstack,Operator now,Operator check)</span></span>{    <span class="hljs-keyword">if</span>(now.moperator == <span class="hljs-string">'('</span>){        push(opstack,now);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now.moperator == <span class="hljs-string">')'</span>){        now = Top(opstack);        pop(opstack);        check = Top(opstack);        <span class="hljs-keyword">while</span>(check.moperator != <span class="hljs-string">'('</span>){            Postfix[PostfixNum] = now.moperator;            PostfixNum++;            pop(opstack);            now = check;            check = Top(opstack);        }        Postfix[PostfixNum] = now.moperator;        PostfixNum++;        pop(opstack);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(check.level &gt;= now.level){       <span class="hljs-keyword">while</span>(check.level &gt;= now.level){        Postfix[PostfixNum] = check.moperator;        PostfixNum++;        pop(opstack);        <span class="hljs-keyword">if</span>(isEmpty(opstack))<span class="hljs-keyword">break</span>;        check = Top(opstack);   }        push(opstack,now);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(check.level &lt; now.level)        push(opstack,now);}<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">FindSolution</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* Postfix)</span></span>{    <span class="hljs-keyword">double</span> Digit[<span class="hljs-number">100000</span>];    <span class="hljs-keyword">int</span> DigitNum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PostfixNum;i++){        <span class="hljs-keyword">if</span>(Postfix[i]&gt;=<span class="hljs-string">'0'</span>&amp;&amp;Postfix[i]&lt;=<span class="hljs-string">'9'</span>){            Digit[DigitNum] = Postfix[i]-<span class="hljs-string">'0'</span>;            DigitNum++;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'+'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second+first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'-'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second-first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'*'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second*first;            DigitNum--;        }        <span class="hljs-keyword">if</span>(Postfix[i]==<span class="hljs-string">'/'</span>){            <span class="hljs-keyword">int</span> firstNum = DigitNum - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> secondNum = DigitNum - <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> first = Digit[firstNum];            <span class="hljs-keyword">double</span> second = Digit[secondNum];            Digit[secondNum]=second/first;            DigitNum--;        }    }    <span class="hljs-keyword">return</span> Digit[<span class="hljs-number">0</span>];}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    InitOperater();    opstack.top = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(s[i]!=<span class="hljs-string">'\0'</span>){        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'0'</span>&amp;&amp;s[i] &lt;= <span class="hljs-string">'9'</span>) {            Postfix[PostfixNum] = s[i];            PostfixNum++;        }        <span class="hljs-keyword">else</span>{            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= <span class="hljs-number">5</span>; j++){                <span class="hljs-keyword">if</span> (s[i] == op[j].moperator){                <span class="hljs-keyword">if</span>(!isEmpty(opstack))operatorCmp(opstack,op[j],Top(opstack));                <span class="hljs-keyword">else</span> push(opstack,op[j]);                }            }        }        i++;    }    <span class="hljs-keyword">while</span>(!isEmpty(opstack)){        Postfix[PostfixNum] = Top(opstack).moperator;        PostfixNum++;        pop(opstack);    }    <span class="hljs-keyword">double</span> solution = FindSolution(Postfix);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf\n"</span>,solution);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PostfixNum;i++){        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>,Postfix[i]);    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL Tree</title>
      <link href="/AVL%E6%A0%91%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0.html"/>
      <url>/AVL%E6%A0%91%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<p>注：本篇的介绍风格会偏笔记向，如果第一次接触AVL树实现，看完本文关于旋转实现的思想还未完全理解，可以看看下面我比较推荐的教程，也作为作者本文的参考博客。<br /><a href="https://b23.tv/av51157423/p1" target="_blank" rel="noopener">AVL树从入门到入土（B站视频 “看完还不懂可以选择弃疗” ）</a></p><p>下面步入正题：</p><h2 id="avl树基本概念"><a class="markdownIt-Anchor" href="#avl树基本概念"></a> AVL树基本概念</h2><ul><li>中文名称：平衡二叉树</li><li>结构特点：树中的任意节点的左右子树的高度之差不超过1的<strong>二叉搜索树</strong></li><li>实现核心操作：查询、插入、删除、旋转</li><li>时间复杂度：查询、插入、删除的时间复杂度均为O(logn)</li></ul><h2 id="avl模块化实现"><a class="markdownIt-Anchor" href="#avl模块化实现"></a> AVL模块化实现</h2><h3 id="结构体声明"><a class="markdownIt-Anchor" href="#结构体声明"></a> 结构体声明</h3><pre class="highlight"><code class="C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>{</span>    <span class="hljs-keyword">int</span> value;    <span class="hljs-keyword">int</span> balance;    AVLNode* left;    AVLNode* right;    AVLNode* parent;};<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLTree</span>{</span>    AVLNode* root;}tree;</code></pre><ul><li>平衡因子BF（Balanced Factor）:该结点的左子树与右子树的高度之差的值。在每个节点中都要附有这样一个标签。</li><li>平衡的识别条件：根据AVL的定义，树中的任意节点的左右子树的高度之差不超过 1。所以，AVL树中的任意结点的平衡因子只可能是：<br />① -1（右子树高于左子树）<br />② 0 （左右子树高度相等）<br />③ 1 （左子树高于右子树）<br />如果因为插入新的节点或删除某一个节点使某个其他节点的BF值变为-2或2，则视为当前状态为不平衡的状态，那么就要通过旋转操作来使其恢复平衡。<br />那么接下来获取高度的方法和二叉搜索树是一样的。</li></ul><h3 id="二叉排序树基本操作"><a class="markdownIt-Anchor" href="#二叉排序树基本操作"></a> 二叉排序树基本操作</h3><h4 id="递归查询即将要插入删除的节点位置"><a class="markdownIt-Anchor" href="#递归查询即将要插入删除的节点位置"></a> 递归查询即将要插入/删除的节点位置</h4><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    <span class="hljs-keyword">if</span>(root==<span class="hljs-number">0</span>){        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">if</span>(root-&gt;value==value){        <span class="hljs-keyword">return</span> root;    }    <span class="hljs-keyword">if</span>(root-&gt;value&gt;value){        <span class="hljs-keyword">if</span>(root-&gt;left)            <span class="hljs-keyword">return</span> select(value,root-&gt;left);        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> root;    }    <span class="hljs-keyword">if</span>(root-&gt;value&lt;value){        <span class="hljs-keyword">if</span>(root-&gt;right)            <span class="hljs-keyword">return</span> select(value,root-&gt;right);        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> root;    }}</code></pre><p>select函数要点：</p><ul><li>这段代码select函数将插入和删除功能中要进行的递归查询操作封装在了一起</li><li>考虑空树情况，返回值为0</li><li>如果value参数值与查询节点的value值相等，返回该节点。这部操作是为删除操作服务的。</li><li>如果value参数值比查询节点值大/小，递归得到该节点的右/左节点的select函数返回值，如果被查询子节点为NULL，则返回该节点，在insert函数中生成新的子节点。</li></ul><h4 id="插入新节点"><a class="markdownIt-Anchor" href="#插入新节点"></a> 插入新节点</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    AVLNode* node=select(value,root); <span class="hljs-comment">// 找到即将被插入的目标节点</span>    <span class="hljs-keyword">if</span>(node==<span class="hljs-number">0</span>){  <span class="hljs-comment">// 如果树为空</span>        tree.root=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));        tree.root-&gt;value=value;        tree.root-&gt;left=tree.root-&gt;right=<span class="hljs-number">0</span>;        tree.root-&gt;parent=<span class="hljs-number">0</span>;        tree.root-&gt;balance=<span class="hljs-number">0</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;value!=value){        <span class="hljs-keyword">if</span>(node-&gt;value&gt;value){            node-&gt;left=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));            node-&gt;left-&gt;value=value;            node-&gt;left-&gt;left=node-&gt;left-&gt;right=<span class="hljs-number">0</span>;            node-&gt;left-&gt;parent=node;            node-&gt;left-&gt;balance=<span class="hljs-number">0</span>;            rebalance(node);        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;value&lt;value){            node-&gt;right=(AVLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AVLNode));            node-&gt;right-&gt;value=value;            node-&gt;right-&gt;left=node-&gt;right-&gt;right=<span class="hljs-number">0</span>;            node-&gt;right-&gt;parent=node;            node-&gt;right-&gt;balance=<span class="hljs-number">0</span>;            rebalance(node);        }    }}</code></pre><p>Insert函数要点：</p><ul><li>考虑空树情况</li><li>通过递归比较树中的节点并插入（这里通过select函数找到被插入节点后再insert函数体内再次进行左右树判断之所以略显繁琐，是为了方便删除节点时复用select函数体内逻辑。）</li><li>[AVL树] <strong>检测并恢复平衡</strong>：rebalance函数。</li></ul><h4 id="删除某一节点"><a class="markdownIt-Anchor" href="#删除某一节点"></a> 删除某一节点</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,AVLNode* root)</span></span>{    AVLNode* node=select(value,root);    <span class="hljs-keyword">if</span>(node-&gt;value==value){        <span class="hljs-keyword">if</span>(node-&gt;left&amp;&amp;node-&gt;right){            delete_Twochild(node);        }<span class="hljs-keyword">else</span>{            delete_NotTwochild(node);        }    }}</code></pre><p>delete函数要点：</p><ul><li>通过select函数递归查找被删除节点，节省效率。</li><li>考虑被删除节点子树个数的情况：<ol><li>有两个子树</li><li>有一个或没有子树</li></ol></li></ul><h5 id="被删除节点有一个子树或没有子树的情况"><a class="markdownIt-Anchor" href="#被删除节点有一个子树或没有子树的情况"></a> 被删除节点有一个子树或没有子树的情况</h5><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_NotTwochild</span><span class="hljs-params">(AVLNode* node)</span></span>{    <span class="hljs-keyword">if</span>(node-&gt;parent==<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(node-&gt;left){            tree.root=node-&gt;left;            node-&gt;left-&gt;parent=<span class="hljs-number">0</span>;        }<span class="hljs-keyword">else</span>{            tree.root=node-&gt;right;            node-&gt;right-&gt;parent=<span class="hljs-number">0</span>;        }    }<span class="hljs-keyword">else</span>{        <span class="hljs-keyword">if</span>(node-&gt;parent-&gt;left==node){            <span class="hljs-keyword">if</span>(node-&gt;left){                node-&gt;parent-&gt;left=node-&gt;left;                node-&gt;left-&gt;parent=node-&gt;parent;            }<span class="hljs-keyword">else</span>{                node-&gt;parent-&gt;left=node-&gt;right;                <span class="hljs-keyword">if</span>(node-&gt;right)                    node-&gt;right-&gt;parent=node-&gt;parent;            }        }<span class="hljs-keyword">else</span>{            <span class="hljs-keyword">if</span>(node-&gt;left){                node-&gt;parent-&gt;right=node-&gt;left;                node-&gt;left-&gt;parent=node-&gt;parent;            }<span class="hljs-keyword">else</span>{                node-&gt;parent-&gt;right=node-&gt;right;                <span class="hljs-keyword">if</span>(node-&gt;right)                    node-&gt;right-&gt;parent=node-&gt;parent;            }        }        rebalance(node-&gt;parent);    }}</code></pre><p>delete_NotTwochild函数要点：</p><ul><li>如果删除节点子节点数量为0或1,执行该函数。</li><li>要考虑到被删除节点是根节点的情况，因为要避免root-&gt;parent为空指针的情况。</li><li>通过node-&gt;parent-&gt;left == node的方式判断该节点是父节点的左孩子还是右孩子。</li><li>先判断出该节点是其父亲节点的左子树还是右子树，方便在删除操作后将目标删除节点的父亲节点的孩子指针指向目标删除节点的孩子节点。</li><li>然后判断目标删除节点的孩子在左子树还是右子树还是不存在。</li><li>不管哪种情况，将目标删除节点的父亲节点的孩子指针指向目标删除节点的孩子节点。</li><li>下一步要将目标删除节点的孩子节点的父亲指针指向删除节点的父亲节点，考虑到目标删除节点没有孩子的情况会导致node-&gt;left-&gt;parent出现空指针情况。所以要在这部之前先判断删除节点是否有孩子。</li><li>[AVL树]完成二叉排序树的基本删除操作后，<strong>检查并恢复平衡</strong>，rebalance函数。</li></ul><pre class="highlight"><code class="">void delete_Twochild(AVLNode* node){    AVLNode* after=getMin(node-&gt;right);    node-&gt;value=after-&gt;value;    delete_NotTwochild(after);}</code></pre><p>delete_Twochild函数要点：</p><ul><li>如果删除节点有两个子节点，执行该函数。</li><li>这种情况只需要在删除节点的右子树中通过getMin函数寻找到value值最小的节点，将删除节点的值与其互换，再将找到的最小value值的节点通过delete_NotTwochild函数删除。</li></ul><pre class="highlight"><code class="">struct AVLNode* getMin(AVLNode* node){    if(node-&gt;left)        getMin(node-&gt;left);    else        return node;}</code></pre><p>getMin函数要点：</p><ul><li>此函数目的在于寻找某一节点作为根节点的树中value值最小的节点。</li><li>根据二叉排序树，递归查找最左侧节点即可。</li></ul><p>至此，二叉排序树基本操作介绍完成。</p><h3 id="avl树旋转操作"><a class="markdownIt-Anchor" href="#avl树旋转操作"></a> AVL树旋转操作</h3><h4 id="获取高度"><a class="markdownIt-Anchor" href="#获取高度"></a> 获取高度</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AVLNode* a)</span></span>{    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>){        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">int</span> rightheight = height(a-&gt;right);    <span class="hljs-keyword">int</span> leftheight = height(a-&gt;left);    <span class="hljs-keyword">return</span> rightheight &gt; leftheight ? (rightheight+<span class="hljs-number">1</span>) : (leftheight+<span class="hljs-number">1</span>);}</code></pre><p>height函数要点：</p><ul><li>考虑空树情况。</li><li>分别递归查询左右子树高度，层层递归向上返回高度累加值。</li></ul><h4 id="检查并回复平衡"><a class="markdownIt-Anchor" href="#检查并回复平衡"></a> 检查并回复平衡</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rebalance</span><span class="hljs-params">(AVLNode* a)</span></span>{    setBalance(a);    <span class="hljs-keyword">if</span>(a-&gt;balance== <span class="hljs-number">-2</span>){        <span class="hljs-keyword">if</span>(a-&gt;left-&gt;balance &lt;=<span class="hljs-number">0</span>){            a=turnRight(a);        }<span class="hljs-keyword">else</span>{            a=turnLeftThenRight(a);        }    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a-&gt;balance==<span class="hljs-number">2</span>){        <span class="hljs-keyword">if</span>(a-&gt;right-&gt;balance&gt;=<span class="hljs-number">0</span>){            a=turnLeft(a);        }<span class="hljs-keyword">else</span>{            a=turnRightThenLeft(a);        }    }    <span class="hljs-keyword">if</span>(a-&gt;parent){        rebalance(a-&gt;parent);    }<span class="hljs-keyword">else</span>{        tree.root=a;    }}</code></pre><ul><li>首先通过setBalance函数刷新被检查节点的balance值。</li><li>开始检查节点balance值：分为四种不平衡情况，对应以下四种旋转方案。</li><li>递归向父亲节点递归检查，直到查到根节点。</li></ul><h4 id="刷新节点balance值"><a class="markdownIt-Anchor" href="#刷新节点balance值"></a> 刷新节点balance值</h4><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBalance</span><span class="hljs-params">(AVLNode* a)</span></span>{    <span class="hljs-keyword">if</span>(a)        a-&gt;balance=height(a-&gt;right)-height(a-&gt;left);}</code></pre><h4 id="单次旋转向左右旋转"><a class="markdownIt-Anchor" href="#单次旋转向左右旋转"></a> 单次旋转（向左/右旋转）</h4><p><img src="/medias/posts/AVL/AVL1.png" alt="Turn Left" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnLeft</span><span class="hljs-params">(AVLNode* a)</span></span>{    AVLNode* b=a-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }    b-&gt;parent=a-&gt;parent;    a-&gt;parent=b;    a-&gt;right=b-&gt;left;    b-&gt;left=a;    <span class="hljs-keyword">if</span>(a-&gt;right!=<span class="hljs-number">0</span>)        a-&gt;right-&gt;parent=a;    setBalance(a);    setBalance(b);    <span class="hljs-keyword">return</span> b;}</code></pre><p><img src="/medias/posts/AVL/AVL2.png" alt="Turn Right" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnRight</span><span class="hljs-params">(AVLNode* a)</span></span>{    AVLNode* b=a-&gt;left;    <span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }    b-&gt;parent=a-&gt;parent;    a-&gt;left=b-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;left!=<span class="hljs-number">0</span>)        a-&gt;left-&gt;parent=a;    a-&gt;parent=b;    b-&gt;right=a;    setBalance(a);    setBalance(b);    <span class="hljs-keyword">return</span> b;}</code></pre><p><img src="/medias/posts/AVL/AVL3.jpg" alt="Turn Right 举例" /></p><p>单次旋转函数要点：</p><ul><li>单次旋转函数触发条件：<br />Turn Right： node-&gt;balance = -2 &amp;&amp; node-&gt;left-&gt;balance &lt;= 0<br />Turn Left：node-&gt;balance = 2 &amp;&amp; node-&gt;right-&gt;balance &gt;= 0</li><li>具体处理步骤：（Turn Right 举例）<br />① 把a节点以及他的右子树移除，a的左子节点b代替a的位置</li></ul><pre class="highlight"><code class="C"><span class="hljs-keyword">if</span>(a-&gt;parent!=<span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span>(a-&gt;parent-&gt;right==a){            a-&gt;parent-&gt;right=b;        }<span class="hljs-keyword">else</span>{            a-&gt;parent-&gt;left=b;        }    }</code></pre><p>②把b节点的右子树移动成为a节点的左子树</p><pre class="highlight"><code class="C">   a-&gt;left=b-&gt;right;    <span class="hljs-keyword">if</span>(a-&gt;left!=<span class="hljs-number">0</span>)        a-&gt;left-&gt;parent=a;</code></pre><p>③让a节点成为b节点的右孩子</p><pre class="highlight"><code class="C">    a-&gt;parent=b;    b-&gt;right=a;</code></pre><p>④刷新a,b节点的balance值。<br />⑤return b节点，让rebalance函数重新从b节点向上检查新树的平衡性。</p><h4 id="两次旋转"><a class="markdownIt-Anchor" href="#两次旋转"></a> 两次旋转</h4><p><img src="/medias/posts/AVL/AVL4.png" alt="Double Rotation" /></p><pre class="highlight"><code class="C"><span class="hljs-function">struct AVLNode* <span class="hljs-title">turnLeftThenRight</span><span class="hljs-params">(AVLNode* a)</span></span>{    a-&gt;left = turnLeft(a-&gt;left);    <span class="hljs-keyword">return</span> turnRight(a);}<span class="hljs-function">struct AVLNode* <span class="hljs-title">turnRightThenLeft</span><span class="hljs-params">(AVLNode* a)</span></span>{    a-&gt;right = turnRight(a-&gt;right);    <span class="hljs-keyword">return</span> turnLeft(a);}</code></pre><p>两次旋转函数要点：</p><ul><li>两次旋转函数触发条件：<br />Turn Right Then Left： node-&gt;balance = 2 &amp;&amp; node-&gt;left-&gt;balance = -1<br />Turn Left Then Right：node-&gt;balance = -2 &amp;&amp; node-&gt;right-&gt;balance = 1</li><li>核心实现思路：对不平衡节点的不平衡方向的子节点先做旋转操作，再对不平衡节点做第二次旋转。</li></ul><p>至此，旋转操作介绍完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
